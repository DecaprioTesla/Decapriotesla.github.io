<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构与算法做题笔记</title>
    <url>/2021/05/10/032%E7%AE%97%E6%B3%95%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fhbimg.b0.upaiyun.com%2F2cd59b961dcd8657fee653bce8877f68f9b590be1fdad-6l57jO_fw658&refer=http%3A%2F%2Fhbimg.b0.upaiyun.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1623463673&t=b71f3d0f1a627330428c323952cb5b2b" alt></p>
<center><font size="4">Live the life you want to live</font></center>
<a id="more"></a>



<h2 id="数据结构篇"><a href="#数据结构篇" class="headerlink" title="数据结构篇"></a>数据结构篇</h2><p>&emsp;数据结构是算法的基础，在初学语言时我们对数据结构的了解多为数组，数组只是一种连续的存储方式，它占用一篇连续的内存空间。除了连续存储方式，还存在一种非连续性存储方式，链表和树是其中典型的代表。这种存储有其优点，在增加和删除元素时较为便捷，同时缺点也比较明显，在查找和删除时较为困难。</p>
<p>&emsp;对于数据结构中，数组，字符串，二叉树，链表，栈，队列等其操作方法总体可以分为两类，一类是线性访问，一种是非线性的访问。线性方式通常为：for循环，while循环。非线性访问通常为使用递归方法（递归，函数调用自身的方法就称作为递归）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性操作</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=;i&lt;;i++)&#123;&#125;</span><br><span class="line"><span class="keyword">while</span>(condition)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非线性操作</span></span><br><span class="line">dfs()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    dfs()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1、链表"><a href="#1、链表" class="headerlink" title="1、链表"></a>1、链表</h3><h3 id="2、二叉树"><a href="#2、二叉树" class="headerlink" title="2、二叉树"></a>2、二叉树</h3><h5 id="2-1-二叉树层序遍历的结果力扣102"><a href="#2-1-二叉树层序遍历的结果力扣102" class="headerlink" title="2.1 二叉树层序遍历的结果力扣102"></a>2.1 二叉树层序遍历的结果<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">力扣102</a></h5><blockquote>
<p>给定一颗二叉树，利用二维数组返回其层序遍历的结果。</p>
</blockquote>
<ul>
<li><strong>题目描述与思路</strong></li>
</ul>
<p>我刚拿到这个题目，没有思路，我很明白二叉树的层序遍历结果，但是你要是让我通过代码来实现，我们肯定能想到，每一层都需要使用一个vector进行<strong>从左到右</strong>存储，那就是想办法要把每一层存下来，同时呢，当前层操作完还能往下一层去操作，每一层操作完后放入到返回数组中</p>
<p>这里给出题目解析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//此题不解，我誓不为人</span></span><br><span class="line"><span class="comment">//最核心的要素是根据一层一层的顺序来搞，你以为你会了cout&lt;&lt;"Hello World!"就OK了?,想的太美！！！！，辣鸡！！！！</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果为空则返回</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; queNode;</span><br><span class="line">        queNode.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!queNode.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size=queNode.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *node=queNode.front();</span><br><span class="line">                temp.push(node-&gt;val);</span><br><span class="line">                queNode.pop();</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>) queNode.push_back(root-&gt;left-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>) queNode.push_back(root-&gt;right-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

















<h2 id="算法篇"><a href="#算法篇" class="headerlink" title="算法篇"></a>算法篇</h2><h3 id="1、动态规划（递归暴力解自顶向下；迭代解法自底向上）"><a href="#1、动态规划（递归暴力解自顶向下；迭代解法自底向上）" class="headerlink" title="1、动态规划（递归暴力解自顶向下；迭代解法自底向上）"></a>1、动态规划（递归暴力解自顶向下；迭代解法自底向上）</h3><h4 id="1-1-基础知识准备"><a href="#1-1-基础知识准备" class="headerlink" title="1.1 基础知识准备"></a>1.1 基础知识准备</h4><p>动态规划的最核心关键在于对递推公式的发掘，初始边界条件的判断和分析。动态规划的入门题目有青蛙跳台问题。这种题目最为直接的解答方式就是寻找当前节点与前面节点之间的计算关系。</p>
<p>A. 动态规划特点：</p>
<ol>
<li>重叠子问题</li>
<li>状态转移方程（最关键）</li>
<li>最优子结构</li>
</ol>
<p>B. 动态规划套路：</p>
<ol>
<li>明确<strong>状态</strong></li>
<li>明确<strong>选择</strong></li>
<li>明确<strong>dp函数/数组</strong>的定义</li>
<li>明确 <strong>base case</strong></li>
</ol>
<p>C.动态规划解法代码框架</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#初始化，basecase</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...]=base</span><br><span class="line">#进行状态转移</span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...]=求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>

<p>D.动态规划经常要求出的答案特点：</p>
<p>A.<strong>求方法数目</strong></p>
<p>B.<strong>求最大最小值</strong>（这个概率真的很高）</p>
<p>C.<strong>是或者否</strong></p>
<h4 id="1-2例题分析"><a href="#1-2例题分析" class="headerlink" title="1.2例题分析"></a>1.2例题分析</h4><blockquote>
<p><strong>①斐波拿数列</strong></p>
</blockquote>
<p>&emsp;它并不是典型的动态规划，因为它不涉及到求最值得问题。也可以说它是一个可以利用递归和迭代举例题目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//画树结构，这个解法是自顶向下的递归解法,每一个Fib函数，只有判断和加法，复杂度为1,但是树上有2^N个节点。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Fib[n<span class="number">-1</span>]+Fib[n<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义一个迭代数组，从最底部自底向上解法，一个for循环，一个数组，时间和空间都为N,空间可只用三个变量进行优化到1.</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>②硬币的面额</strong>（非常经典）</p>
</blockquote>
<p>给定硬币总类数组coins和目标总额，求解<strong>最小</strong>硬币数目。</p>
<ul>
<li>这道题我拿到最先想到的是硬币数组要遍历每一个<strong>面额</strong>（状态），这是关键点，但是并没有立刻想到每一次遍历的下一层的最小值加一就为目标答案。</li>
<li>循环遍历最小值：可以通过一次for循环进行找到</li>
<li>base case是什么，一种为正好分配到0，一种分配到小于0，正好分配到0说明刚好刚好，返回零就OK前面的次数每次加了1；小于0说明那个面额不可以选，前面的都是无效，返回答案-1.</li>
</ul>
<p>建议：画一个树结构来帮助自己理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//使用迭代的解法自底向上进行求解</span></span><br><span class="line">      <span class="comment">//先定义一个dp数组</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount+<span class="number">1</span>,amount+<span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dp.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c:coins)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;c) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i]=min(dp[i],dp[i-c]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==amount+<span class="number">1</span>?<span class="number">-1</span>:dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">③最长公共子序列</a></p>
</blockquote>
<p>这是一道典型的动态规划思维的题目，它是一个二维类型的题目，他的核心在于迭代求解，迭代的推进需要状态转移矩阵来搞。</p>
<p>最长公共子序列，两个数组连线，这种类型的题目都是一个意思，总体过程都是定义dp数组，初始化basecase，然后是明确状态转移的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> lengtha=text1.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> lengthb=text2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(lengtha+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lengthb+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        text1=<span class="string">" "</span>+text1;</span><br><span class="line">        text2=<span class="string">" "</span>+text2;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=lengtha;i++) dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=lengthb;j++) dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lengtha;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lengthb;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这是一个自底向上的方法</span></span><br><span class="line">                <span class="comment">//一定要记住状态转移的明确，</span></span><br><span class="line">                <span class="keyword">if</span>(text1[i]==text2[j]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[lengtha][lengthb]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>④硬币的面额改题：直接灵感来自于爬楼梯问题</p>
</blockquote>
<h3 id="2-背包问题（一种动态规划）"><a href="#2-背包问题（一种动态规划）" class="headerlink" title="2.背包问题（一种动态规划）"></a>2.背包问题（一种动态规划）</h3><blockquote>
<p>引子：给你一个可装载容量为W的背包和N个物品，每个物品有重量和价值两个属性。第i个物品有重量wt[i]的属性和v[i]的价值，现在让你在这个背包里面装物品，最多能装物品的最大价值是多少？</p>
</blockquote>
<ul>
<li><p><strong>step1：明确状态和选择</strong></p>
<p><strong>状态</strong> 背包的空余容量剩多少，可以选择的物品还有那些</p>
<p><strong>选择</strong>：把这个物品装进背包；不把这个物品装进背包</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#初始化basecase</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=base</span><br><span class="line">#进行状态转移</span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...]=求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>step2:明确dp数组的定义</strong></p>
<p>*<em>dp[i] [j] *</em>的含义为对于前i个物品，当背包容量为W时，可以装的最大价值为dp[i] [j]；</p>
<p><strong>base case</strong>: base[0] […]=0，没有物品，各种容量下价值均为0，dp[…] [0] =0背包没有剩余容量，那个物品也放不进去</p>
</li>
<li><p><strong>代码框架</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(W+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">dp[<span class="number">0</span>][...]=<span class="number">0</span>;</span><br><span class="line">dp[...][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> i in [<span class="number">1.</span>.N]:</span><br><span class="line">	<span class="keyword">for</span> w in [<span class="number">1.</span>.M]:</span><br><span class="line">		dp[i][w]=max(</span><br><span class="line">        	把物品i放进背包； dp[i][w]=dp[i<span class="number">-1</span>][w-wt[i]]+wt[i]</span><br><span class="line">            不把物品i放进背包；dp[i][w]=dp[i<span class="number">-1</span>][w]</span><br><span class="line">        )</span><br><span class="line"> <span class="keyword">return</span> dp[N][M];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>关于放与不放物品</strong></p>
<p>一般会加入一个边界条件：if(w-wt[i]&lt;0) dp[i] [w]=dp[i-1] [w];</p>
<p>贴一个自己写的C++代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bagproblems</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;wt,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val,<span class="keyword">int</span> N,<span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(N+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(W+<span class="number">1</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">1</span>;w&lt;=W;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(w-wt[i<span class="number">-1</span>]&lt;<span class="number">0</span>) dp[i][w]=dp[i<span class="number">-1</span>][w];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">             dp[i][w]=max(dp[i<span class="number">-1</span>][w],dp[i<span class="number">-1</span>][w-wt[i<span class="number">-1</span>]]+val[i<span class="number">-1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="3-回溯算法"><a href="#3-回溯算法" class="headerlink" title="3 回溯算法"></a><strong>3 回溯算法</strong></h3><ol>
<li>回溯算法就是暴力穷举算法</li>
<li>穷举过程就是遍历一颗多叉树的过程</li>
<li>回溯算法的代码框架和多叉树遍历的代码框架类似</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回溯算法框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(路径，选择列表)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(满足结束条件)&#123;</span><br><span class="line">        result.add(路径)；</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(选择：选择列表)</span><br><span class="line">    &#123;</span><br><span class="line">        做选择；</span><br><span class="line">        backtrack(路径，选择列表)；</span><br><span class="line">        撤销选择；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多叉树遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(TreeNode child:root.children) </span><br><span class="line">        traverse(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="题1：解码方法"><a href="#题1：解码方法" class="headerlink" title="题1：解码方法**"></a>题1：解码方法**</h4><h4 id="4、双指针-滑动窗口"><a href="#4、双指针-滑动窗口" class="headerlink" title="4、双指针+滑动窗口"></a><strong>4、双指针+滑动窗口</strong></h4><p>双指针技巧主要包括两大类部分：一类是<strong>快慢指针</strong>，一类是<strong>左右指针</strong>。快慢指针主要用来解决链表中的问题，比如典型的判断链表中是否存在环，左右指针主要用来解决数组（或字符串）中的问题，比如二分查找。</p>
<p><strong>PART01快慢指针</strong></p>
<p>如果链表中不存在环形，那么通过不断地去next,那么链表中一定会指向空</p>
<p>![][<a href="https://gblobscdn.gitbook.com/assets%2F-MaSogHyTrHQAjcG_ejV%2Fsync%2Fb4c6f201066b0a410e8ab6d59360abc1bba219ce.jpeg?alt=media]" target="_blank" rel="noopener">https://gblobscdn.gitbook.com/assets%2F-MaSogHyTrHQAjcG_ejV%2Fsync%2Fb4c6f201066b0a410e8ab6d59360abc1bba219ce.jpeg?alt=media]</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast=head;</span><br><span class="line">        ListNode *slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>刷题</tag>
        <tag>工作</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能Web服务器项目</title>
    <url>/2021/07/20/034%E9%AB%98%E6%80%A7%E8%83%BDWeb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="项目学习"><a href="#项目学习" class="headerlink" title="项目学习"></a>项目学习</h1><p>关于web服务器项目的学习，如果只是复现一遍代码性价比太低，如果开源项目是工作需要，或者是在其运行基础上进行修改，那么其对代码整体进行浏览是必不可少的。但若是只是为了学习这个项目的的架构和思想，那么从整体入手，细究某一功能，再瞄准感兴趣的代码块就可以。</p>
<p>对于本项目，最主要的学习内容是为了学习web服务器相关的知识，不需要全部了解，但大部分代码都需要理清脉络，下面学习的脉络如下所式：</p>
<ol>
<li>代码架构，每一个目录负责什么模块（这个部分可以结合开源项目文档，可以加快对项目的理解速度）</li>
<li>编译运行，看看有什么功能；</li>
<li>挑某一个功能，细究器代码实现，比如就先挑“用户登录注册”功能进行研究，在考虑其他的功能；</li>
<li>添加功能，如何在现有的框架下增加一个功能？比如上传文件、上传博客等等？添加留言板？</li>
</ol>
<h1 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h1><p>使用VScode打开项目，该项目的代码框架如下：</p>
<p>.<br>├── build.sh<br>├── CGImysql        //CGI校验程序，负责用户数据与数据库数据对比<br>├── config.cpp       //<br>├── config.h<br>├── http                //实现HTTP 协议连接，销毁等<br>├── LICENSE        //主函数，编译文件等<br>├── lock                 //封装互斥锁，信号量等<br>├── log                  //日志系统的实现<br>├── main.cpp<br>├── makefile<br>├── README.mds<br>├── root                //静态网页数据、图片、视频等<br>├── test_presure  //压力测试webbench等<br>├── threadpool    //线程池实现代码<br>├── timer            //定时器实现代码<br>├── webserver.cpp<br>└── webserver.h</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode每日一题(updating)</title>
    <url>/2021/05/09/033Leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<p><img src="https://pic.rmb.bdstatic.com/5da751880d6acc39c36604bcb09da63f.jpeg" alt></p>
<center><font size="4">每日一刷，每日一结</font></center>

<a id="more"></a>

<h3 id="五月每日一题"><a href="#五月每日一题" class="headerlink" title="五月每日一题"></a>五月每日一题</h3><h4 id="5-09-母亲节，制作m束花所需要的最少天数"><a href="#5-09-母亲节，制作m束花所需要的最少天数" class="headerlink" title="5.09 母亲节，制作m束花所需要的最少天数"></a><strong>5.09</strong> 母亲节，制作m束花所需要的最少天数</h4><p>这一题主要是先对题目做一个概览性的分析：</p>
<ul>
<li><p>1、只要花的数量小于总数，必然无返回，只要花的数量大于或等于总数，则必然有结果</p>
</li>
<li><p>2、存在那么一个days，当大于days必然有连续数组满足，小于days必然不满足，是一个关于days的递增函数，我们就是要找到这个突变点</p>
</li>
<li><p>关于days满不满足，这就是判断不超过days限定条件的最多长度为k的连续子数组的数量</p>
</li>
</ul>
<p>下面给出代码分析：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bloomDay,<span class="keyword">int</span> days,<span class="keyword">int</span> m,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//先定义花的捆数，以及每捆花初始花朵数</span></span><br><span class="line">        <span class="keyword">int</span> kun=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flowers=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length=bloomDay.size();</span><br><span class="line">        <span class="comment">//遍历整个数组,以不超过天数为界线，然后去找连续子数组的长度，实时更新长度与比较长度。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length&amp;&amp;kun&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bloomDay[i]&lt;=days)</span><br><span class="line">            &#123;</span><br><span class="line">                flowers++;</span><br><span class="line">                <span class="keyword">if</span>(flowers==k)</span><br><span class="line">                &#123;</span><br><span class="line">                    kun++;</span><br><span class="line">                    flowers=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> flowers=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kun&gt;=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=bloomDay.size();</span><br><span class="line">        <span class="comment">//花的数目本来就不够</span></span><br><span class="line">        <span class="keyword">if</span>(m*k&gt;length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//找到开放天数的最大值</span></span><br><span class="line">        <span class="keyword">int</span> largestday=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(bloomDay[i]&gt;=largestday) largestday=bloomDay[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=largestday;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> days=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(checkDays(bloomDay,days,m,k)) right=days;</span><br><span class="line">            <span class="keyword">else</span> left=days+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="05-10-二叉树的叶子的遍历：叶子相似的树"><a href="#05-10-二叉树的叶子的遍历：叶子相似的树" class="headerlink" title="05.10 二叉树的叶子的遍历：叶子相似的树"></a><strong>05.10</strong> 二叉树的叶子的遍历：叶子相似的树</h4><p>给定两棵二叉树，首先通过递归方法遍历得到叶子节点，然后比较两颗树的叶子节点是否完全一样</p>
<ul>
<li>首先定义两个vector对叶子节点进行存储</li>
<li>然后写一个dfs进行二叉树叶子节点遍历存储<ul>
<li>1、注意通过引用进行vector的地址传递‘</li>
<li>2、如果为空，结束标志</li>
<li>3、否则如果左右孩子均为空，则说明为叶子，放入vector</li>
<li>4、用dfs继续操作左右孩子</li>
</ul>
</li>
<li>判断两个vector是否相同</li>
</ul>
<p>给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp)</span><span class="comment">//一定要进行引用传递</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//root为空，结束标志</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//左右孩子均为空，叶子标志</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>) temp.push_back(root-&gt;val);</span><br><span class="line">        <span class="comment">//然后分别对左孩子，右孩子执行相同操作</span></span><br><span class="line">        dfs(root-&gt;left,temp);</span><br><span class="line">        dfs(root-&gt;right,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">leafSimilar</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp2;</span><br><span class="line">        dfs(root1,temp1);</span><br><span class="line">        dfs(root2,temp2);</span><br><span class="line">        <span class="keyword">return</span> (temp1==temp2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="05-11位操作，根据异或的加密结果求原码值"><a href="#05-11位操作，根据异或的加密结果求原码值" class="headerlink" title="05.11位操作，根据异或的加密结果求原码值"></a><strong>05.11</strong>位操作，根据异或的加密结果求原码值</h4><p>描述一种加密方式：pre有奇数个元素（元素为1-n），相邻两个异或操作可以得到encoded数组，现在给出encoded数组，需要求出原本的pre数组</p>
<ul>
<li>这道题目最关键的要点在于：若是知道pre第一个数字，其他的结果可以立刻求得。而pre第一个元素的获取方法比较特殊：由于，pre_all=pre_0异或pre_剩余，pre_all可以知道，pre_剩余可以知道(为encode中所有奇数位上元素的异或)。因此pre_0可以知道。</li>
<li>然后即可通过pre_0和encode求得pre所有元素。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">decode</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; encoded)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//最关键的一点：per的除了第一个元素以外的另外偶数个两两之间操作，即为encoded的奇数项的结果；</span></span><br><span class="line">        <span class="comment">//异或交换定律： per全部元素的异或=   除去per[0]异或结果与per[0]异或结果</span></span><br><span class="line">        <span class="comment">//所以：per[0]=per全部元素异或 与除去per[0]之外元素异或（也是encoded的奇数元素下标项异或结果）</span></span><br><span class="line">        <span class="keyword">int</span> n=encoded.size()+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//初始化除去第一个，全部</span></span><br><span class="line">        <span class="keyword">int</span> without_first=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> all=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;encoded.size();i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            without_first=without_first^encoded[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            all=all^i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得目标数组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;per;</span><br><span class="line">        <span class="keyword">int</span> per_first=without_first^all;</span><br><span class="line">        per.push_back(per_first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            per.push_back(per[i<span class="number">-1</span>]^encoded[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> per;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="05-13停留在原地的方案数目（动态规划大法）"><a href="#05-13停留在原地的方案数目（动态规划大法）" class="headerlink" title="05.13停留在原地的方案数目（动态规划大法）"></a><strong>05.13</strong>停留在原地的方案数目（动态规划大法）</h4><p>给定步数step，给定移动数组长度len;每次可以选择不动，向左移动一次，向右移动一次，原地保持不动。求最终回到原点的方案数目</p>
<ul>
<li>刚接触到这道题目，自己感觉应该是动态规划，但是没有想到状态转移方程怎么去写，其实对于这类题目，状态转移方程是比较容易定义的。dp数组定义dp[i] [j] 表示在i步操作到达 j位置的方案数，有了这个定义就可以往下面去一步步推理了。</li>
<li>dp[i] [j]中首先将能到达位置范围缩小一下：j的最大值是选择len和step中较小的那一个 int maxcolumm=min( len-1,steps ) 所以dp的定义 vector&lt;vector<int>&gt;dp( steps+1,vector<int>( maxcolumn+1,0];</int></int></li>
<li>然后就是初始条件和状态转移矩阵的定义：A：都可以为原地保持不动操作；B：向右走得到；C：向左走得到。</li>
<li>然后就是初始条件</li>
</ul>
<p>这里给出代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MODULO = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> steps, <span class="keyword">int</span> arrLen)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//能够到达最远的下标数字。len太大了，步数没那么多也是白瞎。</span></span><br><span class="line">        <span class="keyword">int</span> maxColumn = min(arrLen - <span class="number">1</span>, steps);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(steps + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxColumn + <span class="number">1</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= steps; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxColumn; j++) &#123;</span><br><span class="line">                <span class="comment">//首先，都可以是原地不动而来。</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">//j&gt;0，它可以除了原地不动，也可以是从左边向右移动</span></span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MODULO;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//j不是最右边下标，那么它除了原地不动和右边移动，也可以是从右边向左边而来</span></span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= maxColumn) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j + <span class="number">1</span>]) % MODULO;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[steps][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="05-14整数转罗马数字（类似一种贪心算法）"><a href="#05-14整数转罗马数字（类似一种贪心算法）" class="headerlink" title="05.14整数转罗马数字（类似一种贪心算法）"></a><strong>05.14</strong>整数转罗马数字（类似一种贪心算法）</h4><ul>
<li><p>这题的关键思路在于能够把罗马数字的所有子序列找出来</p>
</li>
<li><p>所有子序列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">son_nums[]=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> son_str[]=&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后通过数组的遍历便可以得到</p>
<p>如果num大于某一个元素，那么就在结果中加上其对应的罗马数字，并且自身减去这个元素，直至不大于这个元素的时候才切换到下一个元素</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//所有子数</span></span><br><span class="line">        <span class="keyword">int</span> son_nums[]=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//所有字数对应的罗马字符</span></span><br><span class="line">        <span class="built_in">string</span> son_str[]=&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="comment">//从大到小，如果大于当前，就减去，并且加上一个罗马字符，直至不大于当前，才切换到下一个，直至为零</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(num&gt;=son_nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                num=num-son_nums[i];</span><br><span class="line">                ans+=son_str[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="05-15罗马数字转整数"><a href="#05-15罗马数字转整数" class="headerlink" title="05.15罗马数字转整数"></a><strong>05.15</strong>罗马数字转整数</h4><p>本题与5.14整数转罗马数字是一类题目，结题思路也基本一致，属于字符串的基本操作，包括字符串选择性擦除，字符串取子串等。</p>
<ul>
<li>首先，定义所有的子罗马数字情况，从大到小排列，以及这些罗马文字对应的阿拉伯数字</li>
<li>然后通过遍历取解决，遍历的关键在于判断当前字符串s的头部串是否有罗马数组当前i对应的字符串相同。相同就将ans加上对应的阿拉伯数字，然后通过erase进行剔除当前罗马字符串</li>
</ul>
<p>实践复杂度为O（n），执行超过了100%，内存方面多了两个数组，以及申请了一个temp串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> son_str[]=&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> son_num[]=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp=s.substr(<span class="number">0</span>,son_str[i].size());</span><br><span class="line">            <span class="keyword">while</span>(temp==son_str[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ans+=son_num[i];</span><br><span class="line">                s=s.erase(<span class="number">0</span>,son_str[i].size());</span><br><span class="line">                temp=s.substr(<span class="number">0</span>,son_str[i].size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="05-20前K个高频单词"><a href="#05-20前K个高频单词" class="headerlink" title="05.20前K个高频单词"></a><strong>05.20</strong>前K个高频单词</h4><blockquote>
<p> 给定一个非空单词列表，返回前K个出现次数最多的单词，返回单词出现频率由高到低，相同频率按字母顺序排序</p>
</blockquote>
<ul>
<li>通过使用map,可以统计次数，由于map是按照键进行排序，我们需要对value进行排序。所以引入vector&lt;pair&lt;string,int&gt;&gt;进行对map进行copy，然后通过sort和cmp进行排序，这是本题最为关键的地方。</li>
<li>巧用pair&lt;string,int&gt;。复习map中的first和second不带括号，为啥不带括号，你用ListNode和TreeNode的思维来考虑就可以了，说白了，也就是一种类似于结构体的东西。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; wordlist1,pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; wordlist2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//注意长度相等的排序</span></span><br><span class="line">        <span class="keyword">if</span>(wordlist1.second==wordlist2.second)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> wordlist1.first&lt;wordlist2.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wordlist1.second&gt;wordlist2.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//引入map，同时，根据map的值进行排序</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;wordlist;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:words)</span><br><span class="line">        &#123;</span><br><span class="line">            wordlist[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//引入vector&lt;pair&lt;stirng,int&gt;&gt;,执行sort</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; PairMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:wordlist)</span><br><span class="line">        &#123;</span><br><span class="line">            PairMap.push_back(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(c.first,c.second));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(PairMap.begin(),PairMap.end(),cmp);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(PairMap[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="05-21不相交的线-动态规划-三叶姐姐教你如何做人"><a href="#05-21不相交的线-动态规划-三叶姐姐教你如何做人" class="headerlink" title="05.21不相交的线(动态规划-三叶姐姐教你如何做人)"></a><strong>05.21</strong>不相交的线(动态规划-三叶姐姐教你如何做人)</h4><p>&emsp;刷题的最高境界就是像三叶这样的大佬，能够将本题立刻联想到动态规划系列经典题目最长递增子序列。此题满足动态规划类型的特征：</p>
<ol>
<li>两个数组（字符串）类型，然后是求最值。dp数组dp[i] [j]也比较容易理解，表示前一个数组的前i个元素，和后一个数组前j个元素所能连线的最大值。</li>
<li>动态规划最关键的状态转移：首先dp数组初始化均为0,然后就是第如果末尾相同，直接连在一起，那肯定是都不连的最大值加一；如果末尾不相同，那肯定是取二者退一个中较大的那个。</li>
</ol>
<p>&emsp;动态规划的特征：动态规划就是一种典型的穷举思想，这是计算机最擅长的事情，而且你要求最值，那我就从最初状态的最值，通过题目条件一步步的去靠近你那个最终状态的最值，靠近的法则就是准确地描述状态转移方程。</p>
<p>&emsp;动态规划要素：状态矩阵，初始化，状态转移循环矩阵，状态转移条件，最终值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> lengtha=text1.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> lengthb=text2.size();</span><br><span class="line">        <span class="comment">//状态转移矩阵，一般求最大值初始化为0，求最小值初始化为取不到结果的最大值</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;dp(lengtha+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(lengthb+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//穷举过程，状态转移矩阵。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lengtha;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lengthb;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这是一个自底向上的方法</span></span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=max(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[lengtha][lengthb];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="05-26栈栈栈栈栈：反转每对括号间的子串"><a href="#05-26栈栈栈栈栈：反转每对括号间的子串" class="headerlink" title="**05.26栈栈栈栈栈：反转每对括号间的子串"></a>**05.26栈栈栈栈栈：反转每对括号间的子串</h4><p>括号是成对出现的，你要反转没两个括号间的字符串，这题方法比较直接，就是遇到左括号将临时字符串入栈，然后将临时字符串清空。遇到字符就把字符加进来，知道遇到了又括号，此时就要翻转临时字符串，同时将栈顶部的元素加上反转后的临时字符串，然后将栈顶部元素pop出去。</p>
<p>总结起来就是：定义一个临时栈和字符串，遇到左括号就全部入栈，并清空，非括号创建字符串，右括号翻转然后将栈顶串加到子串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//巧用栈，遇到左括号就入栈</span></span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(c==<span class="string">'('</span>)&#123;</span><br><span class="line">               st.push(temp);</span><br><span class="line">               temp=<span class="string">""</span>;</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">')'</span>) &#123;</span><br><span class="line">               reverse(temp.begin(),temp.end());</span><br><span class="line">               <span class="comment">//注意加的顺序，栈顶元素在前</span></span><br><span class="line">               temp=st.top()+temp;</span><br><span class="line">               st.pop();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               temp+=c;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer学习笔记(updating)</title>
    <url>/2021/04/02/030%E5%89%91%E6%8C%87offer%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F16549283-92484a07a9b89a4f.jpg&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1620828152&t=85b957b4a0f85f281b5cb3d414f17b68" alt></p>
<center><font size="4">记录学习过程中遇到的问题以及十分重要的知识点</font></center>
<a id="more"></a>

<h1 id="剑指offer题解"><a href="#剑指offer题解" class="headerlink" title="剑指offer题解"></a>剑指offer题解</h1><ol>
<li>前言</li>
<li>正文</li>
<li>结语</li>
</ol>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>剑指offer中一共68道题目，这68道题目中有很多经典题型，面试中有不少题目直接出自上面，尤其是面试中对数据结构知识部分的考察，链表，二叉树，队列，栈这四部分的题目，常见的算法题目这里面也有涉及。不是说做完这68道题目就可以应对很多面试了，只是说高质量地做完这些题目会对面试有很大的帮助。</p>
<p>这部分的题目解析主要参考了CS-Note这个网站对题目的分类方法。</p>
<h2 id="2-正文"><a href="#2-正文" class="headerlink" title="2.正文"></a>2.正文</h2><h3 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h3><h3 id="2-1数组与矩阵"><a href="#2-1数组与矩阵" class="headerlink" title="2.1数组与矩阵"></a>2.1数组与矩阵</h3><blockquote>
<p><strong>T3数组中重复的数字</strong></p>
</blockquote>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>数字在0-n-1之间，长度为n，可以借助map来进行统计</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2021/03/17/027%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<center>常使用的排序方法总结</center>

<a id="more"></a>
<p>&emsp;数据结构中常用的排序方法主要有以下几种：</p>
<ul>
<li><p>冒泡排序</p>
</li>
<li><p>快速排序</p>
</li>
<li><p>希尔排序</p>
</li>
<li><p>堆排序</p>
</li>
<li><p>直接选择排序</p>
</li>
<li><p>直接插入排序</p>
</li>
<li><p>归并排序</p>
</li>
</ul>
<p>下面分别对其介绍，总体可以分为三类：</p>
<p>排序LowB三人组：冒泡排序，选择排序，插入排序</p>
<p>排序NB三人组：快速排序，堆排序，归并排序</p>
<p>其他排序：希尔排序，计数排序，归并排序</p>
<h3 id="0、引子"><a href="#0、引子" class="headerlink" title="0、引子"></a>0、引子</h3><p>这里给出了七种排序算法，根据清华大佬的总结分类可以大致分为三类</p>
<h3 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h3><p>&emsp;冒泡排序是接触排序算法以来最经常使用的排序算法，两两比较相邻数据，如果反序则交换，直到没有反序记录为止。外层循环一次会将最大的值移到最右边，二次将次大值移到最右边。</p>
<h4 id="a-程序"><a href="#a-程序" class="headerlink" title="a.程序"></a>a.程序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BobuleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size() - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>.size() - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[j+<span class="number">1</span>] &lt; <span class="built_in">array</span>[j])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> temp = <span class="built_in">array</span>[j+<span class="number">1</span>];</span><br><span class="line">				<span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">				<span class="built_in">array</span>[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b-复杂度分析"><a href="#b-复杂度分析" class="headerlink" title="b.复杂度分析"></a>b.复杂度分析</h4><p>&emsp;冒泡排序的时间复杂度最简单的情况是原本就是一个递增的数组，比较（n-1）次。最复杂的情况为逆序数组，比较次数为1+2+…+(n-1)+n次，所以时间复杂度为n*(n-1)/2。</p>
<h4 id="c-冒泡排序的算法改进"><a href="#c-冒泡排序的算法改进" class="headerlink" title="c.冒泡排序的算法改进"></a>c.冒泡排序的算法改进</h4><p>&ensp;冒泡排序存在某一趟遍历过程中并没有发生任何交换的情况，这时可以在每一趟开始前先定义一个状态exchange为false,如果在一趟中存在交换，则将exchange改为true。</p>
<p>​    然后在每一趟结束后就可以进行判断exchange，如果还是为false就说明以已经有序，可以结束了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BobuleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.size() - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">bool</span> exchange=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">array</span>.size() - <span class="number">1</span> - i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[j+<span class="number">1</span>] &lt; <span class="built_in">array</span>[j])</span><br><span class="line">			&#123;</span><br><span class="line">                  exchange=<span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">int</span> temp = <span class="built_in">array</span>[j+<span class="number">1</span>];</span><br><span class="line">				<span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">				<span class="built_in">array</span>[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="keyword">if</span>(!exchange) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h3><p>&emsp;快速排序最核心的地方在于找到中轴值，小于中轴在左边，大于中轴在右边，右左交替判断，满足继续移动，不满足换左右，排完然后递归进行。快速排序使用到了递归的思想。</p>
<h4 id="a-程序-1"><a href="#a-程序-1" class="headerlink" title="a.程序"></a>a.程序</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序算法研究：中心轴数据，小于中心轴在左侧，大于中心轴在右侧，递归执行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;Array, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> left = L, right = R;</span><br><span class="line">	<span class="keyword">int</span> pivot = Array[left];</span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//先看最右边，最右边大于中心轴数据则继续往次右边移动</span></span><br><span class="line">		<span class="keyword">while</span> (left &lt; right&amp;&amp;Array[right]&gt;=pivot)</span><br><span class="line">		&#123;</span><br><span class="line">			right--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//右边数据小于了中心轴数据，将右边数据给中心轴位置</span></span><br><span class="line">		<span class="keyword">if</span> (left &lt; right)</span><br><span class="line">		&#123;</span><br><span class="line">			Array[left] = Array[right];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//左边数据一定要小于中心轴数据</span></span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; Array[left] &lt;= pivot)</span><br><span class="line">		&#123;</span><br><span class="line">			left++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//左边数据大于了中心轴数据</span></span><br><span class="line">		<span class="keyword">if</span> (left &lt; right)</span><br><span class="line">		&#123;</span><br><span class="line">			Array[right] = Array[left];<span class="comment">//刚才此位置数据已经小于中心轴数了，现在给他找了一个大于中心轴数的人</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//左右在这里相遇了，中轴数据已经被提溜出来了，现在只需要把中心轴数据放在相遇位置</span></span><br><span class="line">		<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">		&#123;</span><br><span class="line">			Array[left] = pivot;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//此时左变全部小于中轴，右边全部大于中轴，左右使用同样的方法再次进行排序</span></span><br><span class="line">		Quick_Sort(Array, L, right - <span class="number">1</span>);</span><br><span class="line">		Quick_Sort(Array, right + <span class="number">1</span>, R);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码不够直观，我自己又写了一个更加直观的方法，主要是利用partition函数来找到中间的那个可以分割左右的下标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:nums) <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//partition函数的意思是分割，割断的意思</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=nums[left];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="comment">//从右边分析，若是右边有小于pivot的数字，将其放在左边</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]&gt;=mid) right--;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right) nums[left]=nums[right];</span><br><span class="line">        <span class="comment">//切换到左边，若是左边有大于pivot的值，将其放在右边。</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]&lt;=mid) left++;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right) nums[right]=nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left]=mid;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot=partition(nums,L,R);</span><br><span class="line">        QuickSort(nums,L,pivot<span class="number">-1</span>);</span><br><span class="line">        QuickSort(nums,pivot+<span class="number">1</span>,R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    nums.push_back(<span class="number">12</span>);</span><br><span class="line">    nums.push_back(<span class="number">4</span>);</span><br><span class="line">    nums.push_back(<span class="number">8</span>);</span><br><span class="line">    nums.push_back(<span class="number">6</span>);</span><br><span class="line">    nums.push_back(<span class="number">9</span>);</span><br><span class="line">    nums.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> len=nums.size();</span><br><span class="line">    QuickSort(nums,<span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">    Print(nums);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="b-复杂度分析-1"><a href="#b-复杂度分析-1" class="headerlink" title="b.复杂度分析"></a>b.复杂度分析</h4><p>快速排序的时间复杂度为nlongn,空间复杂度的话，主要是递归造成的栈空间的使用，最好的情况递归深度为log2N其空间复杂度为logn</p>
<h4 id><a href="#" class="headerlink" title></a></h4><h3 id="3、希尔排序"><a href="#3、希尔排序" class="headerlink" title="3、希尔排序"></a>3、希尔排序</h3><p>1、<strong>分组</strong></p>
<p>找到一定的间隔，每个间隔内N个元素为一组，然后对每一个子序列进行直接插排序。</p>
<p>希尔排序和直接插入排序关系密不可分。</p>
<p>2、<strong>每一组的组内进行排序</strong></p>
<p>组内排好序后，重新设定一个间隔，重新设的间隔为第一次分组的一半。下一次在进行减小一般，直至最后为1。</p>
<h3 id="4、堆排序"><a href="#4、堆排序" class="headerlink" title="4、堆排序"></a>4、堆排序</h3><p><strong>堆的概念</strong> ：堆是数据结构中二叉树的一种类型，一种特殊的二叉树。根节点（亦称为堆顶）的关键字是堆里所有节点关键字中最大者，称之为大根堆，大根堆要求根节点的关键字即大于等于左子树的关键字值又大于等于右子树的关键字值。</p>
<p><strong>堆的向下调整性质</strong>：假设根节点的左右子树都是堆，但根节点不满足堆的性质，可通过一次向下调整将其变成一个堆。</p>
<p><strong>堆的调整与构造</strong>：农村包围城市，先从最后一个非叶子节点进行二叉树的考虑。</p>
<p><strong>堆排序过程</strong>：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">堆排序的优质文章</a></p>
<ol>
<li>构造一个大顶堆，取堆顶数字（也就是最大值）</li>
<li>再将剩下的数字构造一个大顶堆，取堆顶数字（也就是剩下所有元素的最大值）</li>
<li>重复以上操作，直到取完堆中的数字，最终得到一个从大到小的排序序列</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sortdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by chengxiao on 2016/12/17.</span></span><br><span class="line"><span class="comment"> * 堆排序demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>堆排序</strong>的平均复杂度：O(N*logN)</p>
<h3 id="5、直接选择排序"><a href="#5、直接选择排序" class="headerlink" title="5、直接选择排序"></a>5、直接选择排序</h3><h4 id="a-直接插入排序思想"><a href="#a-直接插入排序思想" class="headerlink" title="a.直接插入排序思想"></a>a.直接插入排序思想</h4><p>主要思想为，对于一个乱序数组，我们首先从全部里面找到一个最小的放在最前面，然后从剩下的里面找到一个最小的再放到次前面，最后得到一个有序的数组。</p>
<ul>
<li>从下标零开始，同时需要记忆min_i和min_value。</li>
<li>如果发现后面的值小于当前，则就需要交换。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> min_value,min_pos;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;。</span><br><span class="line">        min_pos=i;</span><br><span class="line">        <span class="comment">//下面循环负责找i后面最小值及其位置</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;min_value) min_pos=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将i后面最小值及其位置给换到i的位置上，首先最小值位置先把i给扔过去</span></span><br><span class="line">        <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[min_pos];</span><br><span class="line">        nums[min_pos]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b-时间复杂度分析"><a href="#b-时间复杂度分析" class="headerlink" title="b.时间复杂度分析"></a>b.时间复杂度分析</h4><p>这个算法的复杂度显而易见，时间复杂度为O（n^2）;</p>
<h3 id="6、直接插入排序"><a href="#6、直接插入排序" class="headerlink" title="6、直接插入排序"></a>6、直接插入排序</h3><h4 id="a-插入排序思路"><a href="#a-插入排序思路" class="headerlink" title="a.插入排序思路"></a>a.插入排序思路</h4><p>直接插入排序就是我们经常玩扑克牌时多用的方法，每一次我们都认为我们当前的排序是有序的，然后下一个元素进来时，我们通过插入排序将其放入指定的位置，当最后一个元素放完时，插入排序也就结束了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从第一个元素开始，去分析其后面一个元素：</span></span><br><span class="line">        <span class="comment">//若是其后元素小于前面一个元素，就将其插进去</span></span><br><span class="line">        <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">        <span class="keyword">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;nums[j]&gt;temp)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[j+<span class="number">1</span>]=nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j+<span class="number">1</span>]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b-时间复杂度分析-1"><a href="#b-时间复杂度分析-1" class="headerlink" title="b. 时间复杂度分析"></a>b. 时间复杂度分析</h4><p>由于也是两个层大的循环，所以插入排序的时间复杂度为O(n^2)。</p>
<h3 id="7、归并排序"><a href="#7、归并排序" class="headerlink" title="7、归并排序"></a>7、归并排序</h3><ol>
<li><p>将待排序序列中的数字分为若干组，每个数字为一组</p>
</li>
<li><p>将若干组两两合并，保证合并后的数组是有序的</p>
</li>
<li><p>重复进行第二步，最终得到排序后的一组</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>回溯算法总结</title>
    <url>/2021/03/11/026%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<center>leetcode算法题之回溯算法</center>

<a id="more"></a>


<h2 id="回溯算法的定义"><a href="#回溯算法的定义" class="headerlink" title="回溯算法的定义"></a>回溯算法的定义</h2><p>到达一个节点之后有一些选择，选择一个路径往下走，发现没有不能实现预期结果或者不是最优结果在退回至上一步，选择另外一条路径。（在枚举的过程寻找最优解）</p>
<h3 id="1-八皇后问题"><a href="#1-八皇后问题" class="headerlink" title="1. 八皇后问题"></a>1. 八皇后问题</h3><ul>
<li>题目描述</li>
</ul>
<p>给定一个数值N，在N X N 的棋盘上然后满足八皇后的条件：任意两个皇后不在同一个行，不在同一个列，也不在任何一个对角线位置上。请你打印出N皇后的所有解法，其中用Q表示位置上是皇后，用“·”表示位置上没有放皇后。</p>
<ul>
<li>解题思路<br>下面放出一张图，通过这张图片来说明白解题目的思路</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1605603220-baYPtU-file_1605603220485" alt></p>
<p>看到上面这张图，必然离不开递归的思想在里面：从一个节点下到下面的一个子节点有N中选择，每个子节点处又要执行同样的操作。</p>
<p>所以回溯类问题解体的思路如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Backtracking</span><span class="params">(函数参数表)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(终止条件)</span><br><span class="line">    &#123;</span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(选择：本层集和中的元素也就是当前节点子节点数目)</span><br><span class="line">    &#123;</span><br><span class="line">        处理操作</span><br><span class="line">    &#125;</span><br><span class="line">    Backtrack(新的函数列表)；<span class="comment">//递归思想</span></span><br><span class="line">    回溯撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的描述是N皇后进行回溯的过程，主要是先初始化定义一个棋盘结果vector,这个容器可以用来存放N个字符串，每个字符串又有N个字符，而且初始化这个字符串容器的每个内容存放的字符为&ensp;‘·’ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化目标棋盘</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">chessboard</span><span class="params">(n,<span class="built_in">string</span>(n,<span class="string">'.'</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>总体的求解问题的思路大致如下：</p>
<ol>
<li><p>首先定义目标返回数组 result，中间棋盘数组：chessboard，backtrack()函数声明，重点是内部中传递的参数。</p>
</li>
<li><p>按照回溯算法的核心思想backtrack函数（①判断结束条件②做选择并在选择内判断是否继续往下面一项进行，是否进行继续操作③更新选择与条件，继续backtrack④撤销结果）</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">        result.clear();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">chessboard</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">        Backtrack(n, <span class="number">0</span>, chessboard,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//从第一行开始往后面去判断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Backtrack</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> row,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;chessboard,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//是否走到了最后一行了（0-n-1,但是最后一个row+1正好为n）,能成立说明前面都满足放皇后的条件</span></span><br><span class="line">        <span class="keyword">if</span>(row==n)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(chessboard);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在第row行，对尝试在每一列放置皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;n;col++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//验证每一列放置后的合法性，如果合法，更新一下位置“Q”，就可以继续研究下一行下一行</span></span><br><span class="line">            <span class="keyword">if</span>(IsValid(row,col,chessboard,n))</span><br><span class="line">            &#123;</span><br><span class="line">                chessboard[row][col]=<span class="string">'Q'</span>;</span><br><span class="line">                Backtrack(n,row+<span class="number">1</span>,chessboard,result);<span class="comment">//如果一直成功，就一直执行道最后，放在result中。</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//跳出来Backtack说明目前选择的那一列可以放弃了，换下一列研究，因此将原本的Q改回来。</span></span><br><span class="line">                chessboard[row][col]=<span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsValid</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;chessboard,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//检查列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col]==<span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col<span class="number">-1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j]==<span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j]==<span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-计算各个位不同数字的个数"><a href="#2-计算各个位不同数字的个数" class="headerlink" title="2.计算各个位不同数字的个数"></a>2.计算各个位不同数字的个数</h3><ul>
<li><p>题目描述：给定一个非负整数n,然后给出从0&lt;&lt;=x&lt;&lt;=10^n中各个位数字都不相同的个数。</p>
</li>
<li><p>自我感觉：这道题目像是动态规划的问题：</p>
</li>
</ul>
<p>当n=0时，答案就是1，当n&gt;10时，没有必要进行研究，相当于研究到n=10即可</p>
<p>第n个的答案为第n-1个答案再加上那N位的答案</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>回溯算法总结</title>
    <url>/2020/11/19/025%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<center>leetcode算法题之回溯算法</center>

<a id="more"></a>


<h2 id="回溯算法的定义"><a href="#回溯算法的定义" class="headerlink" title="回溯算法的定义"></a>回溯算法的定义</h2><p>到达一个节点之后有一些选择，选择一个路径往下走，发现没有不能实现预期结果或者不是最优结果在退回至上一步，选择另外一条路径。（在枚举的过程寻找最优解）</p>
<h3 id="1-八皇后问题"><a href="#1-八皇后问题" class="headerlink" title="1. 八皇后问题"></a>1. 八皇后问题</h3><ul>
<li>题目描述</li>
</ul>
<p>给定一个数值N，在N X N 的棋盘上然后满足八皇后的条件：任意两个皇后不在同一个行，不在同一个列，也不在任何一个对角线位置上。请你打印出N皇后的所有解法，其中用Q表示位置上是皇后，用“·”表示位置上没有放皇后。</p>
<ul>
<li>解题思路<br>下面放出一张图，通过这张图片来说明白解题目的思路</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1605603220-baYPtU-file_1605603220485" alt></p>
<p>看到上面这张图，必然离不开递归的思想在里面：从一个节点下到下面的一个子节点有N中选择，每个子节点处又要执行同样的操作。</p>
<p>所以回溯类问题解体的思路如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Backtracking</span><span class="params">(函数参数表)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(终止条件)</span><br><span class="line">    &#123;</span><br><span class="line">        存放结果</span><br><span class="line">        <span class="keyword">return</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(选择：本层集和中的元素也就是当前节点子节点数目)</span><br><span class="line">    &#123;</span><br><span class="line">        处理操作</span><br><span class="line">    &#125;</span><br><span class="line">    Backtrack(新的函数列表)；<span class="comment">//递归思想</span></span><br><span class="line">    回溯撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的描述是N皇后进行回溯的过程，主要是先初始化定义一个棋盘结果vector,这个容器可以用来存放N个字符串，每个字符串又有N个字符，而且初始化这个字符串容器的每个内容存放的字符为&ensp;‘·’ </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化目标棋盘</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">chessboard</span><span class="params">(n,<span class="built_in">string</span>(n,<span class="string">'.'</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>总体的求解问题的思路大致如下：</p>
<ol>
<li><p>首先定义目标返回数组 result，中间棋盘数组：chessboard，backtrack()函数声明，重点是内部中传递的参数。</p>
</li>
<li><p>按照回溯算法的核心思想backtrack函数（①判断结束条件②做选择并在选择内判断是否继续往下面一项进行，是否进行继续操作③更新选择与条件，继续backtrack④撤销结果）</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">        result.clear();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">chessboard</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">        Backtrack(n, <span class="number">0</span>, chessboard,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//从第一行开始往后面去判断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Backtrack</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> row,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;chessboard,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//是否走到了最后一行了（0-n-1,但是最后一个row+1正好为n）,能成立说明前面都满足放皇后的条件</span></span><br><span class="line">        <span class="keyword">if</span>(row==n)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(chessboard);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在第row行，对尝试在每一列放置皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;n;col++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//验证每一列放置后的合法性，如果合法，更新一下位置“Q”，就可以继续研究下一行下一行</span></span><br><span class="line">            <span class="keyword">if</span>(IsValid(row,col,chessboard,n))</span><br><span class="line">            &#123;</span><br><span class="line">                chessboard[row][col]=<span class="string">'Q'</span>;</span><br><span class="line">                Backtrack(n,row+<span class="number">1</span>,chessboard,result);<span class="comment">//如果一直成功，就一直执行道最后，放在result中。</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//跳出来Backtack说明目前选择的那一列可以放弃了，换下一列研究，因此将原本的Q改回来。</span></span><br><span class="line">                chessboard[row][col]=<span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsValid</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;chessboard,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//检查列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][col]==<span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col<span class="number">-1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j]==<span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>,j=col+<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>;i--,j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(chessboard[i][j]==<span class="string">'Q'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-计算各个位不同数字的个数"><a href="#2-计算各个位不同数字的个数" class="headerlink" title="2.计算各个位不同数字的个数"></a>2.计算各个位不同数字的个数</h3><ul>
<li><p>题目描述：给定一个非负整数n,然后给出从0&lt;&lt;=x&lt;&lt;=10^n中各个位数字都不相同的个数。</p>
</li>
<li><p>自我感觉：这道题目像是动态规划的问题：</p>
</li>
</ul>
<p>当n=0时，答案就是1，当n&gt;10时，没有必要进行研究，相当于研究到n=10即可</p>
<p>第n个的答案为第n-1个答案再加上那N位的答案</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派/Linux系统常用操作</title>
    <url>/2020/07/19/023%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3841092341,682654896&fm=26&gp=0.jpg" alt></p>
<center>基础命令介绍</center>
<a id="more"></a>

<h2 id="1、文件操作"><a href="#1、文件操作" class="headerlink" title="1、文件操作"></a>1、文件操作</h2><p>树莓派的文件操作基本上是文件目录的切换，创建一个新文件，删除文件，编辑修改文件</p>
<ol>
<li><strong>文件目录</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cd <span class="comment">//回到Linux系统的根目录文件中</span></span><br><span class="line">cd 文件名 <span class="comment">//访问根目录文件下的某个文件名，提示：可以通过Tab键来自动补全文件</span></span><br></pre></td></tr></table></figure></li>
<li><strong>利用filezilla进行树莓派和电脑主机之间的文件交换</strong></li>
</ol>
<p>考虑到树莓派系统编程的流畅性问题，我们可以在主机上进行py、cpp等文件的书写，写完之后再发送至树莓派使其执行文件。文件filezilla软件中输入目标机的IP地址，可以实现文件在树莓派和电脑主机之间的共享，发送文件和接收文件的位置都可以自由改变。<br><img src="https://s1.ax1x.com/2020/07/05/U9udh9.png" alt="U9udh9.png"></p>
<ol start="3">
<li><strong>利用系统UI进行文件操作</strong></li>
</ol>
<p>LInux系统很多操作都是再命令行终端Terminal中执行，但同时系统也有不错的人机界面可供我们使用。入文件目录查找，创建、删除等</p>
<h2 id="2、系统一些基本操作指令"><a href="#2、系统一些基本操作指令" class="headerlink" title="2、系统一些基本操作指令"></a>2、系统一些基本操作指令</h2><ol>
<li><strong>查看CPU温度</strong> </li>
</ol>
<p>担心CPU温度过高影响寿命以及使用性能，可以通过下面指令进行进行CPU温度查看：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/opt/vc/bin/vcgencmd measure_temp</span><br></pre></td></tr></table></figure>
<p>某次显示的温度如下：<br><img src="https://img-blog.csdnimg.cn/20181118081829654.png" alt></p>
<ol start="2">
<li><strong>sudo apt-get 命令</strong></li>
</ol>
<p>sudo 表示 “superuser do”。 它允bai许已验证的用户du以其他用户的身份来运行命令。其zhi他用户可以是dao普通用户或者超级用户。然而，大部分时候我们用它来以提升的权限来运行命令。</p>
<p>APT的使用（Ubuntu Linux软件包管理工具一）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">apt-cache search # ------(package 搜索包)</span><br><span class="line"></span><br><span class="line">sudo apt-get install # ------(package 安装包)sudo apt-get install # -----(package - - reinstall 重新安装包)</span><br><span class="line"></span><br><span class="line">sudo apt-get -f install # -----(强制安装?#<span class="string">"-f = --fix-missing"</span>当是修复安装吧...)</span><br><span class="line"></span><br><span class="line">sudo apt-get remove #-----(package 删除包)</span><br><span class="line"></span><br><span class="line">sudo apt-get remove - - purge # ------(package 删除包，包括删除配置文件等)</span><br><span class="line"></span><br><span class="line">sudo apt-get update #------更新源</span><br><span class="line"></span><br><span class="line">sudo apt-get upgrade #------更新已安装的包</span><br><span class="line"></span><br><span class="line">apt-get source #------(package 下载该包的源代码)</span><br><span class="line"></span><br><span class="line">sudo apt-get clean &amp;&amp; sudo apt-get autoclean # --------清理下载文件的存档 &amp;&amp; 只清理过时的包</span><br><span class="line"></span><br><span class="line">sudo apt-get check #-------检查是否有损坏的依赖</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>sudo raspi-config 命令</strong></li>
</ol>
<p>Raspi-config（Raspberry Pi Software Configuration Tool）是树莓派的官方配置工具，使用它可以对树莓派进行很多的系统配置。比如扩展树莓派的根分区，设置启动树莓派时进入的界面，修改树莓派的默认用户密码、更改语言、设置时区、超频等等。</p>
<p><a href="https://imgchr.com/i/U9lFUS" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/05/U9lFUS.png" alt="U9lFUS.png"></a></p>
<ol start="4">
<li><p><strong>树莓派关机、重启指令</strong></p>
<p>树莓派可以通过下面几个命令来实现安全关机：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo shutdown -h now</span><br><span class="line"></span><br><span class="line">sudo halt</span><br><span class="line"></span><br><span class="line">sudo poweroff</span><br><span class="line"></span><br><span class="line">sudo init <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>上面四行代码都可以，执行一行都可以安全关机。</p>
</li>
</ol>
<p>树莓派重启 定时重启方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br><span class="line"></span><br><span class="line">shutdown -r now</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title>嵌入式课程作业：流水灯+数码管+多线程</title>
    <url>/2020/07/13/024%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1595161575126&di=8659ae9b94f025f9f815c06924256fb5&imgtype=0&src=http%3A%2F%2Ffile.elecfans.com%2Fweb1%2FM00%2F4E%2FAA%2FpIYBAFrEOy6AMgYGAACH13j4y7c721.jpg" alt></p>
<center>2020春季学期《嵌入式系统设计》课程作业</center>

<a id="more"></a>


<h2 id="一、八位流水灯设计"><a href="#一、八位流水灯设计" class="headerlink" title="一、八位流水灯设计"></a>一、八位流水灯设计</h2><h3 id="1-任务需求"><a href="#1-任务需求" class="headerlink" title="1. 任务需求"></a>1. 任务需求</h3><p>电路如图所示，GPIOA管脚低8位连接至LD。请循环依次点亮LD0~LD7，每个LD亮灭时间间隔200ms。（代码中无需初始化GPIOA，请直接写出流水亮灭逻辑伪代码，可直接给GPIOA赋值操作）</p>
<p><img src="https://s1.ax1x.com/2020/07/13/UJfYMq.png" alt="UJfYMq.png"></p>
<h3 id="2-问题分析"><a href="#2-问题分析" class="headerlink" title="2.问题分析"></a>2.问题分析</h3><p>由电路图和任务需求可知，八个LED灯采用共阴极接法分别，LED 0-7 的阳极分别与MCU的GPIO引脚的A0-A7相连，通过以此使能GPIOA的0-7八个引脚依次输出高低电平（GPIO_SetBits，GPIO_ResetBits）实现流水灯效果。</p>
<h3 id="3-流水灯伪代码书写-主函数部分"><a href="#3-流水灯伪代码书写-主函数部分" class="headerlink" title="3.流水灯伪代码书写(主函数部分)"></a>3.流水灯伪代码书写(主函数部分)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化部分</span></span><br><span class="line"></span><br><span class="line">	LED_Init();                  <span class="comment">//LED初始化，在LED.c和LED.h中，同时保证开始时八个引脚为低电平</span></span><br><span class="line">	SysTick_Init(<span class="number">72</span>);            <span class="comment">//初始化时钟，调用delay_ms()函数实现精准延时。</span></span><br><span class="line">	u16 LED_PORTA[<span class="number">8</span>]= &#123;GPIO_Pin_0,GPIO_Pin_1,GPIO_Pin_2,GPIO_Pin_3,GPIO_Pin_4,GPIO_Pin_5,GPIO_Pin_6,GPIO_Pin_7&#125;;                 <span class="comment">//利用LED_PORTA数组存储8个引脚</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//主循环体部分</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		u8 i;</span><br><span class="line">        <span class="comment">//for循环，实现八个引脚电压依次拉高拉低</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">				GPIO_SetBits(LED_PORT,LED_PORTA[i]);  	<span class="comment">//Ai(0-7)引脚高电平，点亮LED</span></span><br><span class="line">				delay_ms(<span class="number">200</span>);							<span class="comment">//延时200ms</span></span><br><span class="line">				GPIO_ResetBits(LED_PORT,LED_PORTA[i]);  <span class="comment">//Ai(0-7)引脚低电平，熄灭LED	</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-工程实现"><a href="#4-工程实现" class="headerlink" title="4.工程实现"></a>4.工程实现</h3><p>笔者在Keil上利用stm32F103库函数模板实现流水灯的工程文件编写，主要任务是对Led.c及其头文件的编写实现对stm32 GPIOA引脚的初始化。工程目录如下：</p>
<p><a href="https://imgchr.com/i/UJozMd" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/13/UJozMd.png" alt="UJozMd.png"></a></p>
<p>led.h头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _led_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _led_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stm32f10x.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*LED端口与引脚定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_PORT 			GPIOA  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_PIN 			(GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_8)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_PORT_RCC	 RCC_APB2Periph_GPIOA</span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>


<p>led.c文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure; <span class="comment">//定义结构体变量</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(LED_PORT_RCC,ENABLE);</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=LED_PIN; <span class="comment">//设置IO口</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;<span class="comment">//设置推挽输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<span class="comment">//设置传输速率</span></span><br><span class="line">	GPIO_Init(LED_PORT,&amp;GPIO_InitStructure); </span><br><span class="line">	GPIO_ResetBits(LED_PORT,LED_PIN);   <span class="comment">//根据共阴极解法，初始化低电平，全部熄灭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-实验搭建及效果"><a href="#5-实验搭建及效果" class="headerlink" title="5.实验搭建及效果"></a>5.实验搭建及效果</h3><p>笔者手头上有一块stm32F103RCT6开发板以及LED小灯若干，所以索性搭建了流水灯实现的硬件电路，其中RCT6需要借助USB转TTL将hex文件烧录到板子中，根据实验原理在面包板上搭建电路，成功实现了LED流水灯效果</p>
<p><a href="https://imgchr.com/i/UJbySU" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/13/UJbySU.png" alt="UJbySU.png"></a></p>
<h2 id="二、SN74HC595-驱动led设计"><a href="#二、SN74HC595-驱动led设计" class="headerlink" title="二、SN74HC595 驱动led设计"></a>二、SN74HC595 驱动led设计</h2><h3 id="1-任务需求-1"><a href="#1-任务需求-1" class="headerlink" title="1.任务需求"></a>1.任务需求</h3><p>电路如图所示，一片SN74HC595DR串并转换芯片连接至8段数码管。请驱动LED，循环显示0<del>9数字，显示间隔时间1s。其中74HC595的三个GPIO选择PB0</del>PB3。</p>
<p><img src="https://s1.ax1x.com/2020/07/13/UJqdje.png" alt="UJqdje.png"></p>
<h3 id="2-问题分析-1"><a href="#2-问题分析-1" class="headerlink" title="2. 问题分析"></a>2. 问题分析</h3><p>本题主要是利用74HC595带锁存移位寄存器串入并处芯片实现将3个GPIO引脚的输入转化为8个并行输出来驱动数码管显示数字。</p>
<h3 id="3-知识回顾"><a href="#3-知识回顾" class="headerlink" title="3. 知识回顾"></a>3. 知识回顾</h3><ul>
<li><strong>74HC595工作原理</strong></li>
</ul>
<p>74HC595芯片管脚的实物图和接线图如图所示，左右各有8个引脚共有16个引脚，其中Q0-Q8用作并行输出，在本题中将连接数码管的八个引脚。一个电源引脚Vcc和一个接地GND。另外，在本题中将MR和OE分别连接电源和地。</p>
<center>

<p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=4134649023,1810018673&fm=26&gp=0.jpg" alt></p>
</center>
Ds（SER）引脚是串行数据输入引脚，连接GPIOB2，根据B2引脚电平的高低将输入1和零；SHcp(SCLK)引脚为输入开关，连接GPIOB１，当该引脚遇到上升沿时将输入数据传送到寄存器中。STcp(RCLK）引脚为输出开关，连接GPIOB0，当该引脚遇到上升沿时使得寄存器中8路并行口输出。

<p><img src="https://s1.ax1x.com/2020/07/13/UtZ3jg.png" alt="UtZ3jg.png"></p>
<p>下面的动图更加形象地说明595芯片的工作过程</p>
<p><img src="https://shumeipai.nxez.com/wp-content/uploads/2016/06/74hc595.gif" alt></p>
<ul>
<li><strong>八段数码管介绍</strong></li>
</ul>
<p>八段数码管的基本原理为：将八个LED灯采用共阳极（或共阴极）的接法，然后通过控制每个LED小灯另一端电平的高或低来实现每个灯的亮与灭进而实现显示不同的数字或者字母。</p>
<p><a href="https://imgchr.com/i/UtR8te" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/14/UtR8te.png" alt="UtR8te.png"></a></p>
<p>数码管的字母对应表：以共阴极数码管为例，下面介绍一下0-9数字的字母对应表，根据自己的数码管实际情况，若为共阳极连接方式，则将0与1分别替换即可。</p>
<p><img src="https://s1.ax1x.com/2020/07/14/UtWeUS.png" alt="UtWeUS.png"></p>
<h3 id="4-工程实现-1"><a href="#4-工程实现-1" class="headerlink" title="4.工程实现"></a>4.工程实现</h3><blockquote>
<p><strong>A.基于Stm32+keil实现</strong></p>
</blockquote>
<p>在流水灯的实验基础之上，在App目录下新建一个smg.c文件用于实现数码管的显示，smg.c的编写与led.c相似，基本上就是GPIO引脚的初始化。</p>
<p>smg.h头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _smg_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _smg_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"system.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*数码管端口引脚的定义*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMG_PORT 			GPIOB   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMG_PIN 			(GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMG_PORT_RCC		RCC_APB2Periph_GPIOB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SMG_Init</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//数码管的初始化函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>smg.c文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* title            : SMG_Init函数</span></span><br><span class="line"><span class="comment">* Author		   : 李振宇</span></span><br><span class="line"><span class="comment">* date:            : 2020.07.13</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SMG_Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;      <span class="comment">//声名结构体变量，初始化GPIO</span></span><br><span class="line">	<span class="comment">/*开启GPIO时钟*/</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(SMG_PORT_RCC,ENABLE);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 模式和输出方式配置 */</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin=SMG_PIN;	  <span class="comment">//GPIO端口</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(SMG_PORT,&amp;GPIO_InitStructure);  <span class="comment">/* 初始化GPIO*/</span></span><br><span class="line">	GPIO_SetBits(SMG_PORT,SMG_PIN);			  <span class="comment">//默认为高电平，共阳极数码管，初始熄灭	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写主函的时候，首先定义一个10*9 的二维数组用于存放0-9 十个数字。在主循环体中按照一下步骤将数据逐位存入74HC595芯片</p>
<ol>
<li>判断输入的为1 or 0</li>
<li>若为1 则将B2拉高，为0将B2拉低</li>
<li>将B1拉高，将B2的输入存入寄存器</li>
<li>再将B1拉低，等待下一次存入</li>
</ol>
<p>main.c 文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* title            : 数码管显示数字主函数</span></span><br><span class="line"><span class="comment">* Author		   : 李振宇</span></span><br><span class="line"><span class="comment">* date:            : 2020.07.13</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"system.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SysTick.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"smg.h"</span></span></span><br><span class="line">u8 num1[<span class="number">10</span>][<span class="number">8</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">								&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">								&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">								&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">								&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">								&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">								&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">								&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">								&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">								&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//变量，时钟，数码管初始化</span></span><br><span class="line">	u8 i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	SysTick_Init(<span class="number">72</span>);</span><br><span class="line">	SMG_Init();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">				<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">8</span>;j++)</span><br><span class="line">				&#123;</span><br><span class="line">						<span class="comment">//1拉高0拉低</span></span><br><span class="line">						<span class="keyword">if</span>(num1[i][j]==<span class="number">1</span>) GPIO_SetBits(SMG_PORT,GPIO_Pin_2);</span><br><span class="line">						<span class="keyword">else</span> GPIO_ResetBits(SMG_PORT,GPIO_Pin_2);</span><br><span class="line"></span><br><span class="line">						<span class="comment">//GPIOB1上升沿；然后置零复位，为下一位数据准备</span></span><br><span class="line">						GPIO_SetBits(SMG_PORT,GPIO_Pin_1);</span><br><span class="line">						GPIO_ResetBits(SMG_PORT,GPIO_Pin_1);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//输出开关B0打开</span></span><br><span class="line">				GPIO_SetBits(SMG_PORT,GPIO_Pin_0);</span><br><span class="line">				<span class="comment">//保持一秒</span></span><br><span class="line">				delay_ms(<span class="number">1000</span>);</span><br><span class="line">				<span class="comment">//重置B0输出开关，为下一个数字输出准备</span></span><br><span class="line">				GPIO_ResetBits(SMG_PORT,GPIO_Pin_0);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个工程目录如下图所示：</p>
<p><a href="https://imgchr.com/i/UtxG4J" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/14/UtxG4J.png" alt="UtxG4J.png"></a></p>
<p>将工程生成的hex文件烧录到stm32F103RCT6中，笔者手头上现有一个八段数码管和一篇595芯片，根据上述接线方法连接电路，其中stm32的B0、B1、B2分别连接595芯片的数据发送端口Ds管脚,寄存器输入开关SHCP管脚以及并行输出开关STCP管脚，正常运行后可以看到如下显示效果：</p>
<p><img src="https://s1.ax1x.com/2020/07/14/UNx4TU.png" alt="UNx4TU.png"></p>
<blockquote>
<p><strong>B.基于树莓派RPI.GPIO实现</strong><br>树莓派的GPIO使用起来非常方便，直接通过编写一个py文件调用RPI.GPIO库和时间库就可以实现本实验需求，基本原理再次不做赘述，smg.py文件编写如下：</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> RPi.GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 串行数据输入引脚连接的GPIO口</span></span><br><span class="line">DS = <span class="number">16</span>       <span class="comment">#PIN 36</span></span><br><span class="line"><span class="comment"># 移位寄存器时钟控制引脚连接的GPIO口</span></span><br><span class="line">SHCP = <span class="number">20</span>     <span class="comment">#PIN 38</span></span><br><span class="line"><span class="comment"># 数据锁存器时钟控制引脚连接的GPIO口</span></span><br><span class="line">STCP = <span class="number">21</span>     <span class="comment">#PIN 40</span></span><br><span class="line"> </span><br><span class="line">RPi.GPIO.setmode(RPi.GPIO.BCM) <span class="comment"># 采用BCM编码</span></span><br><span class="line"><span class="comment">#设置GPIO输出模式</span></span><br><span class="line">RPi.GPIO.setup(DS, RPi.GPIO.OUT)</span><br><span class="line">RPi.GPIO.setup(STCP, RPi.GPIO.OUT)</span><br><span class="line">RPi.GPIO.setup(SHCP, RPi.GPIO.OUT)</span><br><span class="line"><span class="comment">#初始化低SHCP STCP低电平</span></span><br><span class="line">RPi.GPIO.output(STCP, <span class="literal">False</span>)</span><br><span class="line">RPi.GPIO.output(SHCP, <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 通过串行数据引脚向74HC595的传送一位数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setBitData</span><span class="params">(data)</span>:</span></span><br><span class="line">    RPi.GPIO.output(DS, data)</span><br><span class="line">    <span class="comment"># 制造一次移位寄存器时钟引脚的上升沿（先拉低电平再拉高电平）</span></span><br><span class="line">    <span class="comment"># 74HC595会在这个上升沿将DS引脚上的数据存入移位寄存器D0</span></span><br><span class="line">    RPi.GPIO.output(SHCP, <span class="literal">True</span>)</span><br><span class="line">    RPi.GPIO.output(SHCP, <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 指定数码管显示数字num(0-9)，第2个参数是显示不显示小数点（true/false）</span></span><br><span class="line"><span class="comment"># 由于我使用的数码管是共阳数码管，所以设置为低电平的段才会被点亮</span></span><br><span class="line"><span class="comment"># 如果是共阴数码管，那么要将下面的True和False全部颠倒过来，或者统一在前面加上not</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showDigit</span><span class="params">(num, showDotPoint)</span>:</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) :</span><br><span class="line">        setBitData(<span class="keyword">not</span> showDotPoint) <span class="comment"># DP</span></span><br><span class="line">        setBitData(<span class="literal">True</span>)  <span class="comment"># G</span></span><br><span class="line">        setBitData(<span class="literal">False</span>) <span class="comment"># F</span></span><br><span class="line">        setBitData(<span class="literal">False</span>) <span class="comment"># E</span></span><br><span class="line">        setBitData(<span class="literal">False</span>) <span class="comment"># D</span></span><br><span class="line">        setBitData(<span class="literal">False</span>) <span class="comment"># C</span></span><br><span class="line">        setBitData(<span class="literal">False</span>) <span class="comment"># B</span></span><br><span class="line">        setBitData(<span class="literal">False</span>) <span class="comment"># A</span></span><br><span class="line">    <span class="keyword">elif</span> (num == <span class="number">1</span>) :</span><br><span class="line">        setBitData(<span class="keyword">not</span> showDotPoint)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> (num == <span class="number">2</span>) :</span><br><span class="line">        setBitData(<span class="keyword">not</span> showDotPoint)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">elif</span> (num == <span class="number">3</span>) :</span><br><span class="line">        setBitData(<span class="keyword">not</span> showDotPoint)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">elif</span> (num == <span class="number">4</span>) :</span><br><span class="line">        setBitData(<span class="keyword">not</span> showDotPoint)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> (num == <span class="number">5</span>) :</span><br><span class="line">        setBitData(<span class="keyword">not</span> showDotPoint)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">elif</span> (num == <span class="number">6</span>) :</span><br><span class="line">        setBitData(<span class="keyword">not</span> showDotPoint)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">elif</span> (num == <span class="number">7</span>) :</span><br><span class="line">        setBitData(<span class="keyword">not</span> showDotPoint)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">elif</span> (num == <span class="number">8</span>) :</span><br><span class="line">        setBitData(<span class="keyword">not</span> showDotPoint)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">elif</span> (num == <span class="number">9</span>) :</span><br><span class="line">        setBitData(<span class="keyword">not</span> showDotPoint)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">True</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line">        setBitData(<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 拉高STCP并行发送数字</span></span><br><span class="line">    RPi.GPIO.output(STCP, <span class="literal">True</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    RPi.GPIO.output(STCP, <span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 从0显示到9，不显示小数点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">            showDigit(x, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再从0显示到9，显示小数点</span></span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">            showDigit(y, <span class="literal">True</span>)</span><br><span class="line">                     </span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最后清理GPIO口</span></span><br><span class="line">RPi.GPIO.cleanup()</span><br></pre></td></tr></table></figure>

<p>编写完程序后，在文件目录下指令执行smg.py文件</p>
<p><img src="https://s1.ax1x.com/2020/07/14/UNwRSK.png" alt="UNwRSK.png"></p>
<p>笔者利用手上的树莓派4B的三个GPIO引脚连接595的DS、SHCP、STCP三个引脚，可以观察到如下实验现象：</p>
<p><img src="https://s1.ax1x.com/2020/07/14/UUCtq1.png" alt="UUCtq1.png"></p>
<h2 id="三、多线程设计"><a href="#三、多线程设计" class="headerlink" title="三、多线程设计"></a>三、多线程设计</h2><h3 id="1-任务需求-2"><a href="#1-任务需求-2" class="headerlink" title="1.任务需求"></a>1.任务需求</h3><p>多线程设计，每个线程各自打印一个字母，可以交替打印A, B, C字母。</p>
<h3 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2.解决思路"></a>2.解决思路</h3><ol>
<li>让三个线程对应三个标志flag：0，1，2。同时使得三个线程共享一个锁。</li>
<li>通过对状态标志进行判断，如果没有轮到当前线程打印时则通过wait()函数来阻塞当前线程，如果轮到当前状态标志，则执行打印操作。</li>
<li>执行完成后将状态标志flag修改为下一状对应的态标志并将打印次数加1，最后执行notify_all()唤醒当前所有阻塞进程。</li>
<li>三个线程打印次数达到设定值，三个子线程执行结束，跟随主线程一块儿退出<h3 id="3-程序实现"><a href="#3-程序实现" class="headerlink" title="3.程序实现"></a>3.程序实现</h3>笔者用C++编写程序如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">mutex mtx;                 <span class="comment">//互斥信号量</span></span><br><span class="line">condition_variable cv;     <span class="comment">//阻塞等待条件变量</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;              <span class="comment">//状态标志</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;      <span class="comment">//获得一个锁</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;                   <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">10</span>)               <span class="comment">//循环打印次数10</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0</span>)            <span class="comment">//判断打印标志，不为零，则使得线程等待，处于阻塞等待，为0，跳出阻塞，执行打印操作</span></span><br><span class="line">            cv.wait(lk);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">" : "</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        flag = <span class="number">1</span>;                    <span class="comment">//打印完成后，状态标志变为1</span></span><br><span class="line">        count++;                     <span class="comment">//循环次数加一</span></span><br><span class="line">        cv.notify_all();             <span class="comment">//唤醒当前所有的线程，因为此时其他两个线程在wait,而且下一步就要去执行其中一个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">1</span>)</span><br><span class="line">            cv.wait(lk);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">" : "</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        flag = <span class="number">2</span>;</span><br><span class="line">        count++;</span><br><span class="line">        cv.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">2</span>)</span><br><span class="line">            cv.wait(lk);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class="string">" : "</span> &lt;&lt; <span class="string">"C"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        count++;</span><br><span class="line">        cv.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建三个线程，分别执行打印ABC</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread  <span class="title">t1</span><span class="params">(PrintString_1)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread  <span class="title">t2</span><span class="params">(PrintString_2)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread  <span class="title">t3</span><span class="params">(PrintString_3)</span></span>;</span><br><span class="line">    t3.join();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行结果如下（循环打印5次）<br><img src="https://pic.downk.cc/item/5f14101014195aa594cf25cf.jpg" alt></li>
</ol>
]]></content>
      <categories>
        <category>作业</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派无显示器，无网线，远程ssh连接</title>
    <url>/2020/07/04/022%E6%A0%91%E8%8E%93%E6%B4%BE%E6%97%A0%E6%98%BE%E7%A4%BA%E5%99%A8%E6%97%A0%E7%BD%91%E7%BA%BF%E8%BF%9C%E7%A8%8Bssh%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593863783890&di=0d4a3258f354b0a9dba6b65d49b95ab7&imgtype=0&src=http%3A%2F%2Fa.zdmimg.com%2F202006%2F13%2F5ee4d47faecaf2908.jpg_fo710.jpg" alt></p>
<p>之前介绍过树莓派无显示器情况下的网线连接方式，现在介绍不使用网线情况下的远程的ssh连接教程。</p>
<a id="more"></a>

<h2 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h2><ul>
<li>树莓派3/4</li>
<li>内存卡</li>
<li>读卡器</li>
<li>笔记本</li>
<li>wifi(或者手机热点)</li>
</ul>
<h2 id="所用软件"><a href="#所用软件" class="headerlink" title="所用软件"></a>所用软件</h2><ul>
<li><a href="https://www.raspberrypi.org/downloads/raspberry-pi-os/" target="_blank" rel="noopener"><font color="blue">树莓派系统镜像</font></a></li>
<li><a href="https://www.balena.io/etcher/" target="_blank" rel="noopener"><font color="blue">U盘镜像烧写工具 Etcher</font></a></li>
<li><a href="http://www.advanced-ip-scanner.com/cn/" target="_blank" rel="noopener"><font color="blue">IP地址查看工具 Advanced Ip Scanner</font></a></li>
<li><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html" target="_blank" rel="noopener"><font color="blue">远程登陆工具 Etcher</font></a></li>
</ul>
<h2 id="镜像烧写"><a href="#镜像烧写" class="headerlink" title="镜像烧写"></a>镜像烧写</h2><ol>
<li>lect image-&gt;你下的镜像</li>
<li>Select drive-&gt;你的SD卡（注意不要错选为自己电脑的盘，但貌似这个软件会自动选中U盘）</li>
<li>Flash(!注意，烧好后会有个提示BOOT什么的需要格式化，一定要选取消!)</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1079276-2ecf5e9d553a306b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1004/format/webp" alt></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1079276-103046f8bf34f47b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/442/format/webp" alt></p>
<h2 id="设置WIFI开启SSH"><a href="#设置WIFI开启SSH" class="headerlink" title="设置WIFI开启SSH"></a>设置WIFI开启SSH</h2><ol>
<li>此时可以打开刚才镜像完成后的TF卡，在BOOT盘下新增两个文件wpa_supplicant.conf和ssh</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1079276-f0fc3e4ff22ea552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/346/format/webp" alt></p>
<ol start="2">
<li>wpa_supplicant.conf中的内容(注意替换YOUR_WIFI_NAME和YOUR_WIFI_PASSWORD），（key_mgmt=WPA-PSK是wifi加密方式，priority=1是有多个wifi时本wifi的优先级，貌似不太用改):<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">    ssid=<span class="string">"YOUR_WIFI_NAME"</span></span><br><span class="line">    psk=<span class="string">"YOUR_WIFI_PASSWORD"</span></span><br><span class="line">    key_mgmt=WPA-PSK</span><br><span class="line">    priority=<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="查看树莓派的IP地址"><a href="#查看树莓派的IP地址" class="headerlink" title="查看树莓派的IP地址"></a>查看树莓派的IP地址</h2><ol>
<li>将SD卡插入树莓派后连接树莓派的电源</li>
<li>树莓派通电约一分钟后在Advanced Ip Scanner中点击Scan，Manufacturer中那个Raspberry就是你的树莓派，记下树莓派的IP</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/07/04/NxyURP.png" alt="NxyURP.png"></p>
<h2 id="远程登陆树莓派"><a href="#远程登陆树莓派" class="headerlink" title="远程登陆树莓派"></a>远程登陆树莓派</h2><p>打开putty,输入你的树莓派IP地址（我这里是192.168.0.2），输入后提示登陆用户和密码，同样还是用户名：pi 密码：raspberry 登陆成功后的界面如下：<br><a href="https://imgchr.com/i/Nx2eeO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/04/Nx2eeO.png" alt="Nx2eeO.png"></a></p>
<p>此时ls命令一下，可以看到<br><a href="https://imgchr.com/i/Nx2akQ" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/04/Nx2akQ.png" alt="Nx2akQ.png"></a></p>
<h2 id="安装Xrdp"><a href="#安装Xrdp" class="headerlink" title="安装Xrdp"></a>安装Xrdp</h2><p>在命令窗口输入如下指令：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xrdp</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/NxRD4H" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/07/04/NxRD4H.png" alt="NxRD4H.png"></a></p>
<h2 id="用电脑远程桌面连接工具登陆树莓派"><a href="#用电脑远程桌面连接工具登陆树莓派" class="headerlink" title="用电脑远程桌面连接工具登陆树莓派"></a>用电脑远程桌面连接工具登陆树莓派</h2><ol>
<li><p>打开系统的远程桌面工具<br><img src="https://s1.ax1x.com/2020/07/04/NxfwfH.png" alt="NxfwfH.png"></p>
</li>
<li><p>输入树莓派的IP地址<br><img src="https://s1.ax1x.com/2020/07/04/NxWlsP.png" alt="NxWlsP.png"></p>
</li>
<li><p>同样地，输入用户名和密码<br><img src="https://s1.ax1x.com/2020/07/04/NxWhsx.png" alt="NxWhsx.png"></p>
</li>
<li><p>登陆成功后的界面<br><img src="https://s1.ax1x.com/2020/07/04/NxWzef.png" alt="NxWzef.png"></p>
</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过远程的ssh连接，我们只需要保证在统一网络下，将树莓派接通电源，无需再通过网线将树莓派和自己的电脑相连接。可以解决因网线距离有限而带来的问题。</p>
]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习笔记(updating)</title>
    <url>/2020/07/02/029C++%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=296598590,3915271384&fm=26&gp=0.jpg" alt></p>
<center><font size="4">记录学习过程中遇到的问题以及十分重要的知识点</font></center>
<a id="more"></a>

<h2 id="宏定义与条件编译"><a href="#宏定义与条件编译" class="headerlink" title="宏定义与条件编译"></a><strong>宏定义与条件编译</strong></h2><blockquote>
<p><strong>宏定义：</strong></p>
</blockquote>
<ul>
<li>定义形式：</li>
</ul>
<p>用一个指定的标志符来代表一个字符串，其定义为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br></pre></td></tr></table></figure>
<ul>
<li>功能用途：</li>
</ul>
<ol>
<li>可以减少程序中重复性输入某些重用字符串的工作量。</li>
<li>一改全改<blockquote>
<p><strong>条件编译</strong></p>
</blockquote>
</li>
</ol>
<ul>
<li>定义：</li>
</ul>
<p>一般情况下，源程序中所有的行都要参加编译，但有时候需要对程序中某一部分在满足一定的情况下才进行编译，也就是对部分程序限定编译条件；另外，我们希望当满足某一条件时对一组程序进行编译，当满足另外一种情况时则编译另外一组程序。</p>
<ul>
<li>使用方法：</li>
</ul>
<p>主要由两种形式，类似于判断语句，宏定义相当于编译的开关：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPUTER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LANGUAGE</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ''''</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COMPUTER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// </span></span></span><br><span class="line">	<span class="keyword">int</span> size = SIZE;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"这是一个条件编译指令的测试"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//与ifdef相反的因素是ifndef,理解起来方法是完全相同的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LANGUAGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHINA <span class="meta-string">"Chinese"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !LANGUAGE</span></span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"添加CHINA的定义后："</span> &lt;&lt; CHINA &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体与类的定义与区别"><a href="#结构体与类的定义与区别" class="headerlink" title="结构体与类的定义与区别"></a><strong>结构体与类的定义与区别</strong></h2><blockquote>
<p> C结构体、C++结构体基本相同，C++类主要是方法的实现。</p>
</blockquote>
<p><strong>结构体是数据类型的集合</strong></p>
<p><strong>类是数据类型加方法的集合，基本如此，更注重方法。</strong></p>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><strong>malloc</strong></h2><ul>
<li><strong>在链表中插入新的结点时可能会用的到</strong></li>
<li>头文件#include&lt;malloc.h&gt;</li>
<li>功能：分配长度为num_bytes字节的内存块 </li>
<li>说明：如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。 </li>
<li>当内存不再使用时，应使用free()函数将内存块释放</li>
<li>malloc()函数其实就在内存中找一片指定大小的空间，然后将这个空间的首地址范围给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址，这要看malloc()函数中参数size的具体内容。我们这里malloc分配的内存空间在逻辑上连续的，而在物理上可以连续也可以不连续。对于我们程序员来说，我们关注的是逻辑上的连续，因为操作系统会帮我们安排内存分配，所以我们使用起来就可以当做是连续的。</li>
<li>注意的地方：由于malloc函数返回的是void 类型。对于C++，如果你写成：p = malloc (sizeof(int));则程序无法通过编译，报错：“不能将void*赋值给int *类型变量”。所以必须通过(int *)来将强制转换。而对于C，没有这个要求，但为了使C程序更方便的移植到C++中来，建议养成强制转换的习惯<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="comment">//分配128个（可根据实际需要替换该数值）整型存储单元，并将这128个连续的整型存储单元的首地址存储到指针变量p中</span></span><br><span class="line">p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line"><span class="comment">//分配12个double型存储单元，并将首地址存储到指针变量pd中</span></span><br><span class="line"><span class="keyword">double</span> *pd=(<span class="keyword">double</span> *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*<span class="number">12</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> *p;  </span><br><span class="line"> </span><br><span class="line">    p=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);  </span><br><span class="line">    <span class="keyword">if</span>(p)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Memory Allocated at: %x/n"</span>,p);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not Enough Memory!/n"</span>);  </span><br><span class="line">    <span class="built_in">free</span>(p);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="typedef的用法"><a href="#typedef的用法" class="headerlink" title="typedef的用法"></a><strong>typedef的用法</strong></h2><ul>
<li>typedef主要是用来自定义数据类型，可以对所有现存的数据类型进行个性化的重新定义，增加所对应类型变量的个性化程度与单一性，便于在众多变量中将某一大类具有相似关系的变量统一定义。</li>
<li>用在旧的C的代码中（具体多旧没有查），帮助struct。以前的代码中，声明struct新对象时，必须要带上struct，即形式为： struct 结构名 对象名，如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT1</span> <span class="title">p1</span>;</span></span><br></pre></td></tr></table></figure></li>
<li>可能现在在C++中没有那么明显，可以直接写 结构名 对象名，或许，在C++中，typedef的这种用途二不是很大，但是理解了它，对掌握以前的旧代码还是有帮助的，毕竟我们在项目中有可能会遇到较早些年代遗留下来的代码。</li>
<li>但在C中估计某人觉得经常多写一个struct太麻烦了，于是就发明了：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;POINT;</span><br><span class="line"></span><br><span class="line">POINT p1; <span class="comment">// 这样就比原来的方式少写了一个struct，比较省事，尤其在大量使用的时候</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="z-x-gt-y-x-y"><a href="#z-x-gt-y-x-y" class="headerlink" title="z=x&gt;y? x : y"></a><strong>z=x&gt;y? x : y</strong></h2><p>&emsp;其实，这是一个非常基本的知识点，但是有些时候突然见到会想不起来，翻译一下就相当于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&gt;y)</span><br><span class="line">&#123;</span><br><span class="line">    z=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    z=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;也就是可以理解为<strong>result=条件 ? 结果1 : 结果2</strong> 里面的？号是格式要求。也可以理解为条件是否成立，条件成立为结果1，否则为结果2。</p>
<h2 id="memset-函数与数组初始化函数"><a href="#memset-函数与数组初始化函数" class="headerlink" title="memset()函数与数组初始化函数"></a><strong>memset()函数与数组初始化函数</strong></h2><p> &emsp;&emsp;这个函数在socket中多用于清空数组.如:原型是memset(buffer, 0, sizeof(buffer))。简言之，就是用来将数组进行初始化的函数。</p>
<p>&emsp;&emsp;有时候我们并不一定需要动用vector来定义数组，而是可以通过直接定义数组，再结合实际需求通过memset函数来对数组进行初始化操作，这种应用在动态规划类型的题目中应用较多。</p>
<ul>
<li>这个函数有三个参数，前两个为初始化数组对象及其初始化的值，最后一个通常使用sizeof()函数来写，也可以直接写具体大小n。</li>
<li>注意，如果是对指针变量所指向的内存单元进行清零初始化，那么一定要先对这个指针变量进行初始化，即一定要先让它指向某个有效的地址。而且用memset给指针变量如p所指向的内存单元进行初始化时，n 千万别写成 sizeof(p)，这是新手经常会犯的错误。因为 p 是指针变量，不管 p 指向什么类型的变量，sizeof(p) 的值都是 4。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//循环变量</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> *p = str;</span><br><span class="line">    <span class="built_in">memset</span>(str, <span class="number">0</span>, <span class="keyword">sizeof</span>(str));  <span class="comment">//只能写sizeof(str), 不能写sizeof(p)</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\x20"</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int直接来对数组进行定义</span></span><br><span class="line">    <span class="keyword">int</span> m=str.size();</span><br><span class="line">    <span class="keyword">int</span> n=str.size();</span><br><span class="line">    <span class="keyword">int</span> dp[m][n];</span><br><span class="line">    <span class="keyword">int</span> Initial_value;</span><br><span class="line">    <span class="built_in">memset</span>(dp,Initial_value,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vector的使用"><a href="#vector的使用" class="headerlink" title="vector的使用"></a><strong>vector的使用</strong></h2>&emsp;&emsp;vector在C++的功能与数组类似，不过其优点在于其大小长度为动态的，在进行初始化定义的时候并不需要像数组那样去初始化其长度。同时，其特殊之处又决定了vector具体在使用时需要注意的细节：<ul>
<li>往其中加入新元素时需要用 数组名.push_back(加入的元素)&emsp;来实现，<strong>而不能直接访问为初始化或者未定义的下标</strong>。</li>
<li>同时也可以对其进行初始化n个元素。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;<span class="comment">//定义动态数组nums</span></span><br><span class="line"><span class="comment">//nums.[0]=0     //不可以对未定义下标直接赋值</span></span><br><span class="line">nums.psuh_back(<span class="number">1</span>)<span class="comment">//相当于数组中的nums[0]=1;</span></span><br><span class="line">nums[<span class="number">0</span>]=<span class="number">100</span>;     <span class="comment">//可以修改已定义的下标</span></span><br></pre></td></tr></table></figure>
<h2 id="getchar-和system-“puse”-函数"><a href="#getchar-和system-“puse”-函数" class="headerlink" title="getchar()和system(“puse”)函数"></a><strong>getchar()和system(“puse”)函数</strong></h2>这两个可以用在VScode的最后面，用于终端窗口的保持，防止其弹出瞬间就突然消失。</li>
<li>有时，我们不希望终端窗口弹出，因为只需要在下面的终端栏中也可现实。关闭窗口的弹出可以修改.vscode文件下的lanunch.json，将下面的 “externalConsole” 初始设置为false即可。(可根据个人喜好更改)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">"externalConsole"</span>: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="枚举类型menu的用法"><a href="#枚举类型menu的用法" class="headerlink" title="枚举类型menu的用法"></a><strong>枚举类型menu的用法</strong></h2><p>众所周知，C/C++语言可以使用#define和const创建符号常量，而使用enum工具不仅能够创建符号常量，还能定义新的数据类型，但是必须按照一定的规则进行，下面我们一起看下enum的使用方法</p>
<ul>
<li>(1)以下代码定义了这种新的数据类型 - 枚举型<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> DAY</span><br><span class="line">&#123;</span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
(1) 枚举型是一个集合，集合中的元素(枚举成员)是一些命名的整型常量，元素之间用逗号,隔开。</li>
</ul>
<p>(2) DAY是一个标识符，可以看成这个集合的名字，是一个可选项，即是可有可无的项。</p>
<p>(3) 第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。</p>
<p>(4) 可以人为设定枚举成员的值，从而自定义某个范围内的整数。</p>
<p>(5) 枚举型是预处理指令#define的替代。</p>
<p>(6) 类型定义以分号;结束。</p>
<ul>
<li>(2)用typedef关键字将枚举类型定义成别名，并利用该别名进行变量声明<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> workday</span><br><span class="line">&#123;</span><br><span class="line">    saturday,</span><br><span class="line">    sunday = <span class="number">0</span>,</span><br><span class="line">    monday,</span><br><span class="line">    tuesday,</span><br><span class="line">    wednesday,</span><br><span class="line">    thursday,</span><br><span class="line">    friday</span><br><span class="line">&#125; workday; <span class="comment">//此处的workday为枚举型enum workday的别名</span></span><br></pre></td></tr></table></figure>
后面就可以直接使用workday来定义枚举类型了，比如<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">workday today, tomorrow; <span class="comment">//变量today和tomorrow的类型为枚举型workday，也即enum workday</span></span><br></pre></td></tr></table></figure>
具体使用参考示例（C语言）：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Season</span><br><span class="line">&#123;</span><br><span class="line">    spring, summer=<span class="number">100</span>, fall=<span class="number">96</span>, winter</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday</span><br><span class="line">&#125;</span><br><span class="line">Weekday;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Season */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, spring); <span class="comment">// 0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %c \n"</span>, summer, summer); <span class="comment">// 100, d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, fall+winter); <span class="comment">// 193</span></span><br><span class="line"></span><br><span class="line">    Season mySeason=winter;</span><br><span class="line">    <span class="keyword">if</span>(winter==mySeason)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"mySeason is winter \n"</span>); <span class="comment">// mySeason is winter</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==summer)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"x is equal to summer\n"</span>); <span class="comment">// x is equal to summer</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d bytes\n"</span>, <span class="keyword">sizeof</span>(spring)); <span class="comment">// 4 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Weekday */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof Weekday is: %d \n"</span>, <span class="keyword">sizeof</span>(Weekday)); <span class="comment">//sizeof Weekday is: 4</span></span><br><span class="line"></span><br><span class="line">    Weekday today = Saturday;</span><br><span class="line">    Weekday tomorrow;</span><br><span class="line">    <span class="keyword">if</span>(today == Monday)</span><br><span class="line">        tomorrow = Tuesday;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tomorrow = (Weekday) (today + <span class="number">1</span>); <span class="comment">//remember to convert from int to Weekday</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="二重指针"><a href="#二重指针" class="headerlink" title="二重指针"></a><strong>二重指针</strong></h2><p>&emsp;&emsp;所谓的二重指针，就是一种指向指针变量类型的指针。首先对于一个指针变量而言，它需要占用内存空间，即它本身是具有地址的，只不过对应内存空间中存放的是指针变量所指向变量的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"整形数据"</span>&lt;&lt;a&lt;&lt;<span class="string">"的地址为："</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"整形数据"</span>&lt;&lt;b&lt;&lt;<span class="string">"的地址为："</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> *p1=&amp;a;<span class="comment">//定义了默认指向整型变量a的地址的指针变量p1</span></span><br><span class="line"><span class="keyword">int</span> *p2=&amp;b;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针变量p1中存放的地址为："</span>&lt;&lt;p1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针变量p2中存放的地址为："</span>&lt;&lt;p2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//指针变量本身也具有地址：</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针变量p1本身的地址为："</span>&lt;&lt;&amp;p1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"指针变量p2本身的地址为："</span>&lt;&lt;&amp;p2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **q=&amp;p1;<span class="comment">//q是一个指向（指向int数据类型指针）变量p1的指针，注意括号里面的描述，p1本身又是一个指向int数据类型的指针。也就是说，q里面存放的其实是p1的地址，那么*q表示的就是p1本身。所以有**q=*p1=a=1。</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;程序的输出为：</p>
<p><img src="https://s1.ax1x.com/2020/05/04/YCPQW8.png" alt="YCPQW8.png"></p>
<h2 id="异或操作（-）"><a href="#异或操作（-）" class="headerlink" title="异或操作（^）"></a><strong>异或操作（^）</strong></h2><p>&emsp;&emsp;位运算是C++中比较基础的知识点，常见的位运算操作：</p>
<ol>
<li>左移与右移 &lt;&lt;(左移)，&gt;&gt;(右移)，左右移动主要是参照箭头的朝向</li>
<li>与(&amp;)&emsp;或(|)&emsp;取反(~)&emsp;异或(^)</li>
</ol>
<h2 id="关于C-中map和unordered-map的使用"><a href="#关于C-中map和unordered-map的使用" class="headerlink" title="关于C++中map和unordered_map的使用"></a><strong>关于C++中map和unordered_map的使用</strong></h2><p>map是一种以键值对的形式来存储元素的结构，并且也提供相应的成员函数来协助高效的插入，查询和删除键值对，除了map之外，还有一个名为unordered_map的结构，下面研究一下这两者的区别：</p>
<ul>
<li>1、引用的头文件<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span> : <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="built_in">unordered_map</span> : <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>2、存储结构</li>
</ul>
<p>map是将元素存储在一个平衡二叉树中，因此元素是有序存储的</p>
<p>unordered_map是将元素存储在一个哈希表中，正如其名字一样，他并不是有序存储的</p>
<ul>
<li>3、内存使用</li>
</ul>
<p>因为需要额外的内存来存储哈希表，因此unordered_map比map更占用内存</p>
<ul>
<li>4、优缺点分析及其适用处</li>
</ul>
<p><strong>map</strong></p>
<ul>
<li><p>map的存储形式就是以键值对形式存在的，map只要定义完成后，就可以像数组那样去访问键值对以及对键值对进行赋值操作。</p>
</li>
<li><p>map在使用时候需要在头文件中加入#include&lt;map.h&gt;,下面看一个简单的例程。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vec.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hashmap[vec[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印map中的元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"map中若访问不存在的键，则返回 0 "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;hashmap[<span class="number">90000</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>有序性，这是map结构最大的优点，其元素的有序性在很多 应用中都会简化很多的操作树，内部实现一个树使得map的很多操作在logn的时间复杂度下就可以实现，因此效率非常的高</p>
<p>缺点：</p>
<p>空间占用率高，因为map内部实现了树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，使得每一个节点都占用大量的空间</p>
<p>适用处：</p>
<p>对于那些有顺序要求的问题，用map会更高效一些</p>
<p><strong>unordered_map</strong></p>
<p>优点：</p>
<p>因为内部实现了哈希表，因此其查找速度非常的快</p>
<p>缺点：</p>
<p>哈希表的建立比较耗费时间</p>
<p>适用处：</p>
<p>对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<ul>
<li>举例分析:(罗马数字与阿拉伯数字转换，巧用map):</li>
</ul>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<p>Symbol Value<br>I 1<br>V 5<br>X 10<br>L 50<br>C 100<br>D 500<br>M 1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p>Example 1:<br>Input: “III”<br>Output: 3</p>
<p>Example 2:<br>Input: “IV”<br>Output: 4</p>
<p>Example 3:<br>Input: “IX”<br>Output: 9</p>
<p>Example 4:<br>Input: “LVIII”<br>Output: 58<br>Explanation: L = 50, V= 5, III = 3.</p>
<p>Example 5:<br>Input: “MCMXCIV”<br>Output: 1994<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
<p>这道题我们就可以借助map来进行实现，具体代码实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; romanumber;</span><br><span class="line">        romanumber[<span class="string">'I'</span>] = <span class="number">1</span>;</span><br><span class="line">        romanumber[<span class="string">'V'</span>] = <span class="number">5</span>;</span><br><span class="line">        romanumber[<span class="string">'X'</span>] = <span class="number">10</span>;</span><br><span class="line">        romanumber[<span class="string">'L'</span>] = <span class="number">50</span>;</span><br><span class="line">        romanumber[<span class="string">'C'</span>] = <span class="number">100</span>;</span><br><span class="line">        romanumber[<span class="string">'D'</span>] = <span class="number">500</span>;</span><br><span class="line">        romanumber[<span class="string">'M'</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> rlt = romanumber[s[s.size() - <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(romanumber[s[i]] &gt;= romanumber[s[i+<span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                rlt += romanumber[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                rlt -= romanumber[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rlt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="sort-函数的用法"><a href="#sort-函数的用法" class="headerlink" title="sort()函数的用法"></a><strong>sort()函数的用法</strong></h2><p>在进行程序书写过程中，有时候要对向量或者数组按照一定的顺序排列，当然可以通过排序算法进行排序，但是熟练到一定程度之后，我们可以通过直接使用sort()函数来对数组按照自己的需求意愿进行简单的排序。</p>
<ol>
<li>关于sort()函数<br>sort()函数位于C++的标准库#include<algorithm>中，调用标准库里面的排序方法可以实现对数据的排序</algorithm></li>
<li>sort()函数的三个参数<br>void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</li>
</ol>
<p>（1）第一个参数first：是要排序的数组的起始地址。</p>
<p>（2）第二个参数last：是结束的地址（最后一个数据的后一个数据的地址）</p>
<p>（3）第三个参数comp是排序的方法：可以是从升序也可是降序。如果第三个参数不写，则默认的排序方法是从小到大排序,**注意在leetcode，类中定义cmp函数时，如果cmp函数同为public属性，那么bool cmp一定要写为static bool cmp函数。具体原因：</p>
<p>&emsp;写参数cmp时，是把函数名作为实参传递给了sort函数，而sort函数内部是用一个函数指针去调用这个cmp函数的（建议先看下 一文搞懂什么是 函数指针 ），我们知道class普通类成员函数cmp需要通过对象名.cmp()来调用，而sort()函数早就定义好了，那个时候哪知道你定义的是什么对象，所以内部是直接cmp()的，那你不加static时，去让sort()直接用cmp()当然会报错</p>
<p><strong>static静态成员函数不用加对象名，就能直接访问函数（这也是静态成员函数的一大优点）所以加了static就不会报错</strong></p>
<ol start="3">
<li>实例<br>（1）默认情况下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">　　<span class="comment">//sort函数第三个参数采用默认从小到大</span></span><br><span class="line">　　<span class="keyword">int</span> a[]=&#123;<span class="number">45</span>,<span class="number">12</span>,<span class="number">34</span>,<span class="number">77</span>,<span class="number">90</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">55</span>&#125;;</span><br><span class="line">    <span class="comment">//没有对cmp进行定义</span></span><br><span class="line">　　sort(a,a+<span class="number">10</span>);</span><br><span class="line">　　<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">　　<span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
（2）声名情况下<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">main()&#123;</span><br><span class="line">　　<span class="comment">//sort函数第三个参数自己定义，实现从大到小</span></span><br><span class="line">　　<span class="keyword">int</span> a[]=&#123;<span class="number">45</span>,<span class="number">12</span>,<span class="number">34</span>,<span class="number">77</span>,<span class="number">90</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">55</span>&#125;;</span><br><span class="line">　　sort(a,a+<span class="number">10</span>,cmp);</span><br><span class="line">　　<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">　　　　<span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">　　<span class="keyword">return</span> a&gt;b;<span class="comment">//按照自己希望的的方式来定义大小关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="栈stack的使用"><a href="#栈stack的使用" class="headerlink" title="栈stack的使用"></a><strong>栈stack的使用</strong></h2><p>C++中提供了栈的标准模板库，在使用栈时需要在头文件中加入：include <stack>。下面简单介绍栈在使用过程中的一些常用的指令操作：</stack></p>
<ol>
<li>stack 可以看作一种新的容器类型，但是它的特殊之处就在于栈的存取操作是先进后出。</li>
<li>入栈操作：s.push() 将括号里面的内容压入栈内</li>
<li>打印，取出，获得栈顶元素： s.top() </li>
<li>出栈操作：s.pop() 将栈里面的元素出栈</li>
<li>判断栈是否为空栈：s.empty()</li>
</ol>
<p>上面描述的一些操作如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈的实现</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; zhan;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; element.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		zhan.push(element[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"栈的大小为（栈中的元素个数为）："</span> &lt;&lt; zhan.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (!zhan.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; zhan.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		zhan.pop();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-中队列的使用"><a href="#C-中队列的使用" class="headerlink" title="C++中队列的使用"></a><strong>C++中队列的使用</strong></h2><p>队列也是C++中的一种标准容器类，其最大的特点就是先进先出。在头文件中要加入 #include <queue>头文件，下面介绍一些其常用的指令操作：</queue></p>
<ol>
<li><strong>push()</strong> 向队列中插入新的元素，由于队列是基于先进先出，在执行push()操作时，新插入的元素放在队尾</li>
<li><strong>pop()</strong> 将位于队列中最靠前的值拿掉</li>
<li><strong>size()</strong> 返回队列的长度，队列中元素的个数</li>
<li><strong>empty()</strong> 判断队列是否为一个空队列，若是队列为空，则返回true</li>
<li><strong>front()</strong> 返回当前队列的第一个元素<br>使用案例如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队列的操作</span></span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; my_queue;</span><br><span class="line">	my_queue.push(<span class="string">"Hello World"</span>);</span><br><span class="line">	my_queue.push(<span class="string">"I love China"</span>);</span><br><span class="line">	my_queue.push(<span class="string">"Nice to meet you"</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"队头的元素为："</span> &lt;&lt; my_queue.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"队的长度为"</span> &lt;&lt; my_queue.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!my_queue.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"队中第"</span> &lt;&lt; i &lt;&lt; <span class="string">"个元素为："</span> &lt;&lt; my_queue.front() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		i++;</span><br><span class="line">		my_queue.pop();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="利用数组创建一个链式结构"><a href="#利用数组创建一个链式结构" class="headerlink" title="利用数组创建一个链式结构"></a><strong>利用数组创建一个链式结构</strong></h2><p>有时候我们已经获得链表中的数据元素项目，将链表中的元素已经顺序存入了一个vector中，现在需要将vector中的元素构造出一个链表，可以通过下面描述的方法进行操作：</p>
<ol>
<li>首先我们新建一个节点,并将节点指向为NULL listNOde *head=nullptr;</li>
<li>对容器进行遍历，每次遍历时，都新建一个新的节点，并且节点的储值赋值为 当前容器中的元素</li>
<li>令当前新建的节点的下一节点指向 head；</li>
<li>最后再将当前节点指向head<br>所以，以上四步操作就实现了不断将新元素放在链表的头部，若是向不改变顺序，应将容器进行逆序遍历，代码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">listNode *head=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=nums.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">    listNode *current=<span class="keyword">new</span> listNode(nums[i]);</span><br><span class="line">    current-&gt;next=head;</span><br><span class="line">    head=current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="指针中函数指针-amp-amp-指针函数"><a href="#指针中函数指针-amp-amp-指针函数" class="headerlink" title="指针中函数指针&amp;&amp;指针函数"></a><strong>指针中函数指针&amp;&amp;指针函数</strong></h2><h3 id="1-函数指针"><a href="#1-函数指针" class="headerlink" title="1.函数指针"></a>1.函数指针</h3><p>说实话，函数指针就是一个特殊的<strong>指针</strong>，指针都使用来指向一种类型的地址的，函数指针也不例外。函数在执行时，内存会为函数开辟一块专用的内存地址使用，所谓函数指针，就是专门指向函数入口的指针。</p>
<p>其定义同其他类型指针定义有相似之处</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">指针类型+指针名</span></span><br><span class="line"><span class="comment">int *p;</span></span><br><span class="line"><span class="comment">char *c;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了一个函数指针add，用于指向返回值为int，并且有两个int参数的函数</span></span><br><span class="line"><span class="keyword">int</span> (*add)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>



<p>下面附上一段完整的程序代码，定义了一个函数指针（*add）,用来指向求和函数addFunc</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addfunc</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> (*add)(<span class="keyword">int</span>, <span class="keyword">int</span>) = addfunc;</span><br><span class="line">        <span class="comment">//两种方法都可以</span></span><br><span class="line">        <span class="comment">//int (*add)(int, int) = &amp;addfunc;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = (*add)(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//两种方法都可以，建议使用第一种</span></span><br><span class="line">        <span class="comment">//int result = add(1, 2);</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"通过函数指针调用函数进行计算结果："</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        result = addfunc(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"通过直接调用函数进行计算结果："</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-指针函数"><a href="#2-指针函数" class="headerlink" title="2.指针函数"></a>2.指针函数</h3><p>指针函数重点强调函数，函数都具有类型，类似于整形函数的返回值类型为整型，指针函数的返回值类型为指针。</p>
<p>下面的范例实现了返回一个类型为指针的指针函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                A(<span class="keyword">int</span> a) &#123;</span><br><span class="line">                        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> a;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值为指向类型A的指针的函数</span></span><br><span class="line"><span class="function">A *<span class="title">createA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个指向A类型的指针，并调用createA创建一个A类型的对象</span></span><br><span class="line">        A* b = createA();</span><br><span class="line">        <span class="comment">//通过指针调用类的方法</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"b-&gt;a = "</span> &lt;&lt; b-&gt;getA() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="循环表达式：for-auto-c-temp"><a href="#循环表达式：for-auto-c-temp" class="headerlink" title="循环表达式：for(auto c:temp)"></a><strong>循环表达式：for(auto c:temp)</strong></h2><p>此种用法可以不考虑数组的长度来对数组进行遍历，尤其经常使用在map结构中，可以实现map第一个元素的跳动。下面的例程中，map中存放了数组元nums中每个元素出现的次数，我们需要找出元素数目小于2的，可以通过for(auto c:temp)来开启循环语句。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//剑指offer 56题，找出数组中不重复的两个数字</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//出现次数统计</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c:temp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c.second&lt;<span class="number">2</span>) ans.push_back(c.first); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二进制位操作"><a href="#二进制位操作" class="headerlink" title="二进制位操作"></a><strong>二进制位操作</strong></h2><p>有时候需要对数据进行按位操作，在C++中，可以直接对整形数据进行按位逻辑操作，移位操作</p>
<ul>
<li><strong>（&amp;）</strong> a&amp;b，a,b均为int类型，表示将整形数字a和b将</li>
</ul>
<h2 id="C-C-内存四区"><a href="#C-C-内存四区" class="headerlink" title="C/C++内存四区"></a><strong>C/C++内存四区</strong></h2><ul>
<li>代码区：存放函数体的二进制代码，由操作系统管理</li>
<li>全局区：存放全局变量，静态变量与常量</li>
<li>栈区：存放局部变量，函数的形参值，函数的返回值</li>
<li>堆区：由程序员手动创建（new malloc等），使用后需要手动释放（free,delete等）。</li>
</ul>
<h2 id="C-sort的时间复杂度"><a href="#C-sort的时间复杂度" class="headerlink" title="C++ sort的时间复杂度"></a><strong>C++ sort</strong>的时间复杂度</h2><p>C++中sort的时间复杂度为nlogn,有些题目中对时间复杂度有要求，二分查找logn 肯定要好于直接遍历n;</p>
<h2 id="String-中-find-与substr-的用法"><a href="#String-中-find-与substr-的用法" class="headerlink" title="String 中 find()与substr()的用法"></a><strong>String 中 find()与substr()的用法</strong></h2><p>C++中find函数用于寻找子字符串，substr()用于分割字符串，find函数返回EOF 表示不是子字符串，是字符串则返回第一次出现时的下标，</p>
<p>C++中substr用于分割，s.substr(star起始位置下表，<strong>len往后寻找元素个数</strong>),注意第二个元素的意义为向后寻找的元素的个数。</p>
<p>程序实例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s = <span class="string">"hello"</span>;</span><br><span class="line">	<span class="built_in">string</span> t = <span class="string">"ll"</span>;</span><br><span class="line">	<span class="built_in">string</span> m = <span class="string">"all"</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.find(t) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s.find(m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span> (s.find(m) == EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"返回EOF，m不为s的子字符串"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> temp = s.substr(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维数组vector定义"><a href="#二维数组vector定义" class="headerlink" title="二维数组vector定义"></a><strong>二维数组vector定义</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(rows,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(coloumns,<span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="Set类模板的用法"><a href="#Set类模板的用法" class="headerlink" title="Set类模板的用法"></a>Set类模板的用法</h2><p>SET（）是一种包含已排序对象的关联容器。 set集合容器实现了红黑树（Red-Black Tree）的平衡二叉检索树的数据结构，在插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，<strong>它不会插入相同键值的元素，而采取忽略处理，而且会自动完成排序</strong>。</p>
<p>set种常用的操作有：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">begin();            <span class="comment">// 返回指向第一个元素的迭代器</span></span><br><span class="line">end();              <span class="comment">// 返回指向迭代器的最末尾处（即最后一个元素的下一个位置）</span></span><br><span class="line">clear();            <span class="comment">// 清除所有元素</span></span><br><span class="line">count();            <span class="comment">// 返回某个值元素的个数</span></span><br><span class="line">empty();            <span class="comment">// 如果集合为空，返回true</span></span><br><span class="line">equal_range();      <span class="comment">//返回集合中与给定值相等的上下限的两个迭代器</span></span><br><span class="line">erase()–删除集合中的元素</span><br><span class="line">find()–返回一个指向被查找到元素的迭代器</span><br><span class="line">get_allocator()–返回集合的分配器</span><br><span class="line">insert()–在集合中插入元素</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//一个遍历的例子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">set</span> &lt;<span class="keyword">int</span>&gt; s; <span class="comment">//建立set容器 </span></span><br><span class="line">    s.insert(<span class="number">6</span>);<span class="comment">//插入6 </span></span><br><span class="line">    s.insert(<span class="number">1</span>);<span class="comment">//插入1</span></span><br><span class="line">    s.insert(<span class="number">9</span>);<span class="comment">//插入9 </span></span><br><span class="line">    s.insert(<span class="number">1</span>);<span class="comment">//插入1 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)<span class="comment">//定义前向迭代器遍历输出 </span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit = s.rbegin(); rit != s.rend(); rit++)<span class="comment">//定义反向迭代器遍历输出 </span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d "</span>,*rit);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态成员static"><a href="#静态成员static" class="headerlink" title="静态成员static"></a>静态成员static</h2><ol>
<li><p>先介绍一下static：在成员变量和成员函数前加static 时，那么该成员变量或成员函数的使用范围就限定在当前程序文件下，不能为外部文件调用（默认不加static 时相当于external属性，可在文件外被调用）</p>
</li>
<li><p>这里给出C语言中static的官方说法：</p>
</li>
</ol>
<p>给C语言初学者：<strong>利用static属性隐藏变量和函数名字</strong>C程序员使用static属性在模块内部隐藏变量和函数声明，就像你在Java和C++中使用public和private声明一样。C源代码文件扮演模块的角色。任何声明带有static属性的全局变量或者函数都是模块私有的。类似的，任何声明为不带static属性的全局变量和函数都是公共的，可以被其它模块访问。尽可能用static属性来保护你的变量和函数是很好的编程习惯。</p>
<ol start="3">
<li>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0。</li>
</ol>
<h2 id="C-类中的静态成员函数和静态成员变量"><a href="#C-类中的静态成员函数和静态成员变量" class="headerlink" title="C++类中的静态成员函数和静态成员变量"></a>C++类中的静态成员函数和静态成员变量</h2><p>C++类中用static 修饰成员函数和成员变量，可以总结的规律有：</p>
<p>1、静态成员函数和变量不再专属于每一个对象了，它是属于类的，可以通过对象进行调用，也可以通过类进行调用。</p>
<p>2、静态成员函数只能访问修改静态成员，而不能访问修改非静态成员（因为非静态是属于共有的）</p>
<h2 id="优先级队列-priority-queue"><a href="#优先级队列-priority-queue" class="headerlink" title="优先级队列 priority_queue"></a>优先级队列 priority_queue</h2><p>优先级队列需要使用头文件#include<queue> ，它是维护一个元素为大根堆，其本质是通过一个大根堆实现的。</queue></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pop():弹出堆顶部元素（大根堆，弹出最大元素）</span><br><span class="line">push():插入元素到队伍尾部（大根堆会重新排序）</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>14nm工艺背后的神预言家</title>
    <url>/2020/05/21/021%E5%9B%A0%E7%89%B9%E5%B0%9414nm%E5%B7%A5%E8%89%BA%E8%83%8C%E5%90%8E%E7%9A%84%E7%A5%9E%E9%A2%84%E8%A8%80%E5%AE%B6/</url>
    <content><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1590084131984&di=d116cbed4be671c4dbc7d48e88d0fe75&imgtype=0&src=http%3A%2F%2Ftravel.cnr.cn%2Flist%2F20161012%2FW020161012413115561528.jpg" alt></p>
<p>就说两件事</p>
<a id="more"></a>

<h2 id="1、推荐一本不错的文集"><a href="#1、推荐一本不错的文集" class="headerlink" title="1、推荐一本不错的文集"></a>1、推荐一本不错的文集</h2><p>根据作者表述的意思，这本书出版前好几百个教授一致通过</p>
<p>你看，就是下面这本&emsp;↓&emsp;↓&emsp;↓</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1593855759574&di=29a32cedecf063ae828f8db0b391737e&imgtype=0&src=http%3A%2F%2Fe.hiphotos.baidu.com%2Fbaike%2Fw%3D268%2Fsign%3Df47f3ea9bf315c6043956ce9b5b0cbe6%2Fc8177f3e6709c93d644e9c4b9c3df8dcd00054c9.jpg" alt></p>
<p>前几天老美又想拿华为下刀了,过去很长一段时间我们低调行事，但这两年老美似乎发现有些不对劲了，于是就有了现在的贸易战，也使我们在高调的狂欢后冷静下来开始意识到到核心技术是买不来的。在芯片这个行当，核心技术在于制造芯片的光刻机。</p>
<p>现如今，手机芯片当下已经实现了7nm甚至5nm制程工艺，但是英特尔的处理器，最近几年一直停留在14nm,所以最新的几代产品一直被诟病“挤牙膏”</p>
<p>今天偶然看到一张图片，仿佛找到了原因，可能是英特尔管理层内部也有我等蛤丝，不想打破长者当年的预言。</p>
<p>下面给大家看一下当时长者的预言截图&emsp;↓&emsp;↓&emsp;↓</p>
<p><a href="https://pic.downk.cc/item/5ec69e33c2a9a83be537acf0.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ec69e33c2a9a83be537acf0.jpg" alt></a></p>
<p>只能说一句，High level !!!</p>
<p>可见作者当年对我国信息技术产业发展的蓝图构想还是蛮好的，</p>
<p>只是考虑到当时的大形势，很多事情实施起来的确会很困难。</p>
<p>这也是到今天我们为什么要挺华为，因为他擅长研究我们在过去没能真正放在焦点上没去实施的东西，在过去那种大形势下我们忽略的关键东西。</p>
<h2 id="2、睡前有感："><a href="#2、睡前有感：" class="headerlink" title="2、睡前有感："></a>2、睡前有感：</h2><p>今天是2020.05.21,一个比较特殊的日子，我也念诗两句不相干的句子：</p>
<ol>
<li><p>事未经历而为难，</p>
</li>
<li><p>过眼滔滔云共雾，</p>
</li>
</ol>
<p><a href="https://pic.downk.cc/item/5ec6a2acc2a9a83be541893d.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ec6a2acc2a9a83be541893d.jpg" alt="科大西校区钱学森像"></a></p>
<center>科大西校区钱学森像，摄于2020年初冬</center>




]]></content>
      <categories>
        <category>膜蛤</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统（三）处理机调度与死锁</title>
    <url>/2020/05/21/020%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E5%92%8C%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3621867659,1152751757&fm=26&gp=0.jpg" alt></p>
<a id="more"></a>
<h2 id="一、处理机调度算法的目标"><a href="#一、处理机调度算法的目标" class="headerlink" title="一、处理机调度算法的目标"></a>一、处理机调度算法的目标</h2><h3 id="处理机调度算法的共同目标"><a href="#处理机调度算法的共同目标" class="headerlink" title="处理机调度算法的共同目标"></a>处理机调度算法的共同目标</h3><ul>
<li>资源利用率:CPU的利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)</li>
<li>公平性</li>
<li>平衡性</li>
<li>策略强制执行<h3 id="批处理系统的目标"><a href="#批处理系统的目标" class="headerlink" title="批处理系统的目标"></a>批处理系统的目标</h3></li>
<li>平均周转时间短</li>
<li>系统吞吐量高</li>
<li>处理机利用率高<h3 id="分时系统的目标"><a href="#分时系统的目标" class="headerlink" title="分时系统的目标"></a>分时系统的目标</h3></li>
<li>响应时间快</li>
<li>均衡性<h3 id="实时系统目标"><a href="#实时系统目标" class="headerlink" title="实时系统目标"></a>实时系统目标</h3></li>
<li>截止时间的保证</li>
<li>可预测性<h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3></li>
<li>高级调度（作业调度）<ul>
<li>分时系统无需作业调度，因为需要交互</li>
<li>批处理系统需要作业调度</li>
</ul>
</li>
<li>中级调度（和挂起有关）</li>
<li>低级调度（进程调度）<ul>
<li>进程调度是最基本的调度，任何操作系统都有进程调度。</li>
<li>低级调度的三个基本机制<ul>
<li>排队器</li>
<li>分派器</li>
<li>上下文切换</li>
</ul>
</li>
<li>进程调度方式<ul>
<li>非抢占方式</li>
<li>抢占方式<ul>
<li>优先权原则</li>
<li>短进程优先原则</li>
<li>时间片原则</li>
</ul>
</li>
</ul>
</li>
<li>进程调度的任务<ul>
<li>保存处理机的现场信息</li>
<li>按某种算法选取进程</li>
<li>把处理器分配给进程</li>
</ul>
</li>
<li>进程调度的算法<ul>
<li>优先级调度算法<ul>
<li>优先级调度算法的类型<ul>
<li>非抢占式优先级调度算法<ul>
<li>等当前进程执行完以后，再执行另一个优先权最高的进程</li>
<li>这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 </li>
</ul>
</li>
<li>抢占式优先级调度算法<ul>
<li>不等当前进程结束，直接抢处理机</li>
<li>常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。</li>
</ul>
</li>
</ul>
</li>
<li>优先级的类型<ul>
<li>静态优先级<ul>
<li>优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0<del>7或0</del>255中的某一整数， 又把该整数称为优先数。</li>
<li>可以参考BIOS系统中设置boot的优先级</li>
</ul>
</li>
<li>动态优先级<ul>
<li>在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>轮转调度算法<ul>
<li>基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行</li>
<li>进程切换时机<ul>
<li>时间片未用完，进程完成</li>
<li>时间片到，进程未完成</li>
</ul>
</li>
<li>时间片大小的确定<ul>
<li>太小利于短作业，增加系统切换开销</li>
<li>太长就退化为FCFS算法</li>
<li>一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成</li>
</ul>
</li>
<li>一般来说，平均周转时间将比SJF长，但是有较好的响应时间</li>
</ul>
</li>
<li>多队列调度算法</li>
<li>多级反馈队列调度算法<ul>
<li>调度机制<ul>
<li>设置多个就绪队列</li>
<li>每个队列都采用FCFS算法</li>
<li>按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行</li>
</ul>
</li>
<li>调度算法的性能<ul>
<li>对于终端型用户，由于作业小，感觉满意</li>
<li>对于短批处理作业用户，周转时间也较小</li>
<li>长批处理作业用户，也能够得到执行</li>
</ul>
</li>
</ul>
</li>
<li>基于公平原则的调度算法<ul>
<li>保证调度算法</li>
<li>公平分享调度算法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二、-作业与作业调度"><a href="#二、-作业与作业调度" class="headerlink" title="二、 作业与作业调度"></a>二、 作业与作业调度</h2><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ul>
<li>作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。<h3 id="作业控制块JCB"><a href="#作业控制块JCB" class="headerlink" title="作业控制块JCB"></a>作业控制块JCB</h3></li>
<li>为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。<h3 id="作业步"><a href="#作业步" class="headerlink" title="作业步"></a>作业步</h3></li>
<li>作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。<h3 id="作业运行的三个阶段"><a href="#作业运行的三个阶段" class="headerlink" title="作业运行的三个阶段"></a>作业运行的三个阶段</h3></li>
<li>收容阶段</li>
<li>运行阶段</li>
<li>完成阶段<h3 id="作业运行的三个状态"><a href="#作业运行的三个状态" class="headerlink" title="作业运行的三个状态"></a>作业运行的三个状态</h3></li>
<li>后备状态</li>
<li>运行状态</li>
<li>完成状态<h3 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h3></li>
<li>接纳多少个作业</li>
<li>接纳哪些作业<h3 id="先来先服务-first–come-first–served，FCFS-调度算法"><a href="#先来先服务-first–come-first–served，FCFS-调度算法" class="headerlink" title="先来先服务(first–come first–served，FCFS)调度算法"></a>先来先服务(first–come first–served，FCFS)调度算法</h3></li>
<li>比较有利于长作业，而不利于短作业。</li>
<li>有利于CPU繁忙的作业，而不利于I/O繁忙的作业。<h3 id="短作业优先-short-job-first，SJF-的调度算法"><a href="#短作业优先-short-job-first，SJF-的调度算法" class="headerlink" title="短作业优先(short job first，SJF)的调度算法"></a>短作业优先(short job first，SJF)的调度算法</h3></li>
<li>优点<ul>
<li>比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；</li>
<li>提高系统的吞吐量；</li>
</ul>
</li>
<li>缺点<ul>
<li>必须预知作业的运行时间</li>
<li>对长作业非常不利，长作业的周转时间会明显地增长</li>
<li>在采用SJF算法时，人–机无法实现交互</li>
<li>该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理<h3 id="优先级调度算法-priority–scheduling-algorithm，PSA"><a href="#优先级调度算法-priority–scheduling-algorithm，PSA" class="headerlink" title="优先级调度算法(priority–scheduling algorithm，PSA)"></a>优先级调度算法(priority–scheduling algorithm，PSA)</h3><h3 id="高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN"><a href="#高响应比优先调度算法-Highest-Response-Ratio-Next-HRRN" class="headerlink" title="高响应比优先调度算法(Highest Response Ratio Next,HRRN)"></a>高响应比优先调度算法(Highest Response Ratio Next,HRRN)</h3></li>
</ul>
</li>
<li>原理<ul>
<li>在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行</li>
<li>优先权=(等待时间+要求服务时间)/要求服务时间=响应时间/要求服务时间=1+等待时间/要求服务时间</li>
</ul>
</li>
<li>特点<ul>
<li>如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业</li>
<li>当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法</li>
<li>对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机<h2 id="三、实时调度-HRT和SRT任务"><a href="#三、实时调度-HRT和SRT任务" class="headerlink" title="三、实时调度(HRT和SRT任务)"></a>三、实时调度(HRT和SRT任务)</h2><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3></li>
</ul>
</li>
<li>提供必要信息<ul>
<li>就绪时间</li>
<li>开始截止时间和完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
</li>
<li>系统处理能力强<ul>
<li>∑(Ci/Pi)≤1</li>
<li>N个处理机:∑(Ci/Pi)≤N</li>
</ul>
</li>
<li>采用抢占式调度机制</li>
<li>具有快速切换机制<ul>
<li>对中断的快速响应能力</li>
<li>快速的任务分派能力<h3 id="实时调度算法的分类"><a href="#实时调度算法的分类" class="headerlink" title="实时调度算法的分类"></a>实时调度算法的分类</h3></li>
</ul>
</li>
<li>非抢占式调度算法<ul>
<li>非抢占式轮转调度算法</li>
<li>非抢占式优先调度算法</li>
</ul>
</li>
<li>抢占式调度算法<ul>
<li>基于时钟中断的抢占式优先级调度算法</li>
<li>立即抢占的优先级调度算法<h3 id="最早截止时间优先EDF-Earliest-Deadline-First-算法"><a href="#最早截止时间优先EDF-Earliest-Deadline-First-算法" class="headerlink" title="最早截止时间优先EDF(Earliest Deadline First)算法"></a>最早截止时间优先EDF(Earliest Deadline First)算法</h3></li>
</ul>
</li>
<li>根据任务的开始截至时间来确定任务的优先级<ul>
<li>截至时间越早，优先级越高</li>
</ul>
</li>
<li>非抢占式调度方式用于非周期实时任务</li>
<li>抢占式调度方式用于周期实时任务<h3 id="最低松弛度优先LLF-Least-Laxity-First-算法"><a href="#最低松弛度优先LLF-Least-Laxity-First-算法" class="headerlink" title="最低松弛度优先LLF(Least Laxity First)算法"></a>最低松弛度优先LLF(Least Laxity First)算法</h3></li>
<li>类似EDF</li>
<li>算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。</li>
<li>松弛度例子<ul>
<li>例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms<h3 id="优先级倒置-Priority-inversion-problem"><a href="#优先级倒置-Priority-inversion-problem" class="headerlink" title="优先级倒置(Priority inversion problem)"></a>优先级倒置(Priority inversion problem)</h3></li>
</ul>
</li>
<li>优先级倒置的形成<ul>
<li>高优先级进程被低优先级进程延迟或阻塞。</li>
</ul>
</li>
<li>优先级倒置的解决方法<ul>
<li>简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占</li>
<li>实用的:建立在动态优先级继承基础上的<h2 id="四、死锁概述"><a href="#四、死锁概述" class="headerlink" title="四、死锁概述"></a>四、死锁概述</h2><h3 id="资源问题"><a href="#资源问题" class="headerlink" title="资源问题"></a>资源问题</h3></li>
</ul>
</li>
<li>可重用性资源<ul>
<li>计算机外设</li>
</ul>
</li>
<li>消耗性资源<ul>
<li>数据，消息</li>
</ul>
</li>
<li>可抢占性资源<ul>
<li>不引起死锁</li>
<li>CPU，内存 </li>
</ul>
</li>
<li>不可抢占性资源<ul>
<li>光驱，打印机<h3 id="计算机系统中的死锁"><a href="#计算机系统中的死锁" class="headerlink" title="计算机系统中的死锁"></a>计算机系统中的死锁</h3></li>
</ul>
</li>
<li>竞争不可抢占性资源引起死锁</li>
<li>竞争可消耗资源引起死锁</li>
<li>进程推进顺序不当引起死锁<h3 id="死锁的定义，必要条件和处理方法"><a href="#死锁的定义，必要条件和处理方法" class="headerlink" title="死锁的定义，必要条件和处理方法"></a>死锁的定义，必要条件和处理方法</h3></li>
<li>定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的</li>
<li>产生死锁的必要条件<ul>
<li>互斥条件</li>
<li>请求和保存条件</li>
<li>不可抢占条件</li>
<li>循环等待条件<ul>
<li>如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件</li>
</ul>
</li>
</ul>
</li>
<li>处理死锁的方法<ul>
<li>预防死锁<ul>
<li>静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。</li>
<li>预防死锁的策略<ul>
<li>破坏”请求和保存”条件<ul>
<li>第一种协议<ul>
<li>所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源</li>
<li>优点:简单，易行，安全</li>
<li>缺点<ul>
<li>资源被严重浪费，严重地恶化了资源的利用率</li>
<li>使进程经常会发生饥饿现象</li>
</ul>
</li>
</ul>
</li>
<li>第二种协议<ul>
<li>它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源</li>
</ul>
</li>
</ul>
</li>
<li>破坏”不可抢占”条件<ul>
<li>当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请</li>
</ul>
</li>
<li>破坏”循环等待”条件<ul>
<li>对系统所以资源类型进行线性排序，并赋予不同的序号</li>
<li>例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>避免死锁<ul>
<li>动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法</li>
<li>避免死锁的策略<ul>
<li>系统安全状态<ul>
<li>安全状态<ul>
<li>某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如&lt;p1,p2…pn&gt;来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列</li>
</ul>
</li>
<li>安全状态之例</li>
<li>由安全状态向不安全状态的转换</li>
</ul>
</li>
<li>利用银行家算法避免死锁<ul>
<li>含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待</li>
<li>银行家算法中的数据结构<ul>
<li>可用资源向量 Available[m]：m为系统中资源种类数，Available[j]=k表示系统中第j类资源数为k个。</li>
<li>最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]=k表示进程i对j类资源的最大需求数为中k。</li>
<li>分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] = k表示进程i已分得j类资源的数目为k个。</li>
<li>需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]=k 表示进程i   还需要j类资源k个。Need[i,j]=Max[i,j] - Allocation[i,j]</li>
</ul>
</li>
<li>银行家算法</li>
<li>安全性算法</li>
<li>银行家算法之例</li>
<li>解题<ul>
<li>矩阵</li>
<li>列表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>检测死锁<ul>
<li>死锁的检测与解除<ul>
<li>死锁的检测<ul>
<li>资源分配图<ul>
<li>简化步骤<ul>
<li>选择一个没有阻塞的进程p</li>
<li>将p移走，包括它的所有请求边和分配边</li>
<li>重复步骤1，2，直至不能继续下去</li>
</ul>
</li>
</ul>
</li>
<li>死锁定理<ul>
<li>若一系列简化以后不能使所有的进程节点都成为孤立节点</li>
</ul>
</li>
<li>检测时机<ul>
<li>当进程等待时检测死锁 （其缺点是系统的开销大）</li>
<li>定时检测</li>
<li>系统资源利用率下降时检测死锁</li>
</ul>
</li>
<li>死锁检测中的数据结构</li>
</ul>
</li>
<li>死锁的解除<ul>
<li>抢占资源</li>
<li>终止(或撤销)进程</li>
<li>终止进程的方法<ul>
<li>终止所有死锁进程</li>
<li>逐个终止进程<ul>
<li>代价最小<ul>
<li>进程的优先级的大小</li>
<li>进程已执行了多少时间，还需时间</li>
<li>进程在运行中已经使用资源的多少，还需多少资源</li>
<li>进程的性质是交互式还是批处理的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>付出代价最小的死锁解除算法<ul>
<li>是使用一个有效的挂起和解除机构来挂起一些死锁的进程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>解除死锁</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>讲讲PID控制</title>
    <url>/2020/05/13/019%E8%AE%B2%E8%AE%B2PID/</url>
    <content><![CDATA[<p>PID控制应该算是应用非常广泛的控制算法了。小到控制一个元件的温度，大到控制无人机的飞行姿态和飞行速度等等，都可以使用PID控制。这里我们从原理上来理解PID控制。<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1589388237123&di=5d1be6f7217713811f8b5edaffe08aea&imgtype=0&src=http%3A%2F%2Feeskill.com%2FUploads%2F2014_06%2Farticle%2Fc53875ec9a.jpg" alt></p>
<a id="more"></a>
<h2 id="00什么是PID控制"><a href="#00什么是PID控制" class="headerlink" title="00什么是PID控制"></a>00什么是PID控制</h2><p>PID是proportion integration differentiation三个英文单词的简称，也即是我们翻译过来的比例、积分、微分控制。控制的原理图如开头的封面图片所示。我们都知道控制系统的最理想效果为是系统的实际输出与期望达到的输出完全相同，但实际情况来说输入与输出之间总存在一定的偏差，所以我们就要采用控制方法来实现更优的控制</p>
<h2 id="01大白话PID控制"><a href="#01大白话PID控制" class="headerlink" title="01大白话PID控制"></a>01大白话PID控制</h2><h3 id="1-1比例控制算法（比例因子Kp）"><a href="#1-1比例控制算法（比例因子Kp）" class="headerlink" title="1.1比例控制算法（比例因子Kp）"></a>1.1比例控制算法（比例因子Kp）</h3><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1589388473322&di=3738c6b03b14e6b9606957fcedd105e4&imgtype=0&src=http%3A%2F%2Fimg002.hc360.cn%2Fk3%2FM03%2F6C%2F7A%2FwKhQv1eQo5iEQGXRAAAAAIKey-s745.jpg" alt><br>我们先说PID中最简单的比例控制，抛开其他两个不谈，用一个经典的例子吧。假设我有一个水缸，最终的控制目的是要保证水缸里的水位永远的维持在1米的高度。假设初试时刻，水缸里的水位是0.2米，那么当前时刻的水位和目标水位之间是存在一个误差的error，且error为0.8.这个时候，假设旁边站着一个人，这个人通过往缸里加水的方式来控制水位。如果单纯的用比例控制算法，就是指加入的水量u和误差error是成正比的。即</p>
<center>u=kp*error</center>

<p><strong>假设kp取0.5</strong></p>
<ol>
<li>那么t=1时（表示第1次加水，也就是第一次对系统施加控制），那么u=0.5*0.8=0.4，所以这一次加入的水量会使水位在0.2的基础上上升0.4，达到0.6.</li>
<li>接着，t=2时刻（第2次施加控制），当前水位是0.6，所以error是0.4。u=0.5*0.4=0.2，会使水位再次上升0.2，达到0.8.</li>
<li>如此这么循环下去，水位最终会达到一米。就是比例控制算法的运行方法。</li>
</ol>
<p>但是，单单的比例控制存在着一些不足，其中一点就是 –稳态误差！像上述的例子，根据kp取值不同，系统最后都会达到1米，不会有稳态误差。但是，考虑另外一种情况，假设这个水缸在加水的过程中，存在漏水的情况，假设每次加水的过程，都会漏掉0.1米高度的水。仍然假设kp取0.5，那么会存在着某种情况，假设经过几次加水，水缸中的水位到0.8时，水位将不会再变换！！！因为，水位为0.8，则误差error=0.2. 所以每次往水缸中加水的量为u=0.5*0.2=0.1.同时，每次加水缸里又会流出去0.1米的水！！！加入的水和流出的水相抵消，水位将不再变化！！</p>
<p>也就是说，我的目标是1米，但是最后系统达到0.8米的水位就不在变化了，且系统已经达到稳定。由此产生的误差就是稳态误差了。（在实际情况中，这种类似水缸漏水的情况往往更加常见，比如控制汽车运动，摩擦阻力就相当于是“漏水”，控制机械臂、无人机的飞行，各类阻力和消耗都可以理解为本例中的“漏水”）</p>
<p>所以，单独的比例控制，在很多时候并不能满足要求。</p>
<h3 id="1-2积分控制算法（积分因子Ki）"><a href="#1-2积分控制算法（积分因子Ki）" class="headerlink" title="1.2积分控制算法（积分因子Ki）"></a>1.2积分控制算法（积分因子Ki）</h3><p>还是用上面的例子，如果仅仅用比例，可以发现存在暂态误差，最后的水位就卡在0.8了。于是，在控制中，我们再引入一个分量，该分量和误差的积分是正比关系。所以，比例+积分控制算法为：</p>
<center>u=kp*error+ ki∗∫ error</center>

<p>还是用上面的例子来说明，第一次的误差error是0.8，第二次的误差是0.4，至此，误差的积分（离散情况下积分其实就是做累加），∫∫error=0.8+0.4=1.2. 这个时候的控制量，除了比例的那一部分，还有一部分就是一个系数ki乘以这个积分项。由于这个积分项会将前面若干次的误差进行累计，所以可以很好的消除稳态误差（假设在仅有比例项的情况下，系统卡在稳态误差了，即上例中的0.8，由于加入了积分项的存在，会让输入增大，从而使得水缸的水位可以大于0.8，渐渐到达目标的1.0.）这就是积分项的作用。</p>
<h3 id="1-3微分控制算法（微分因子Kd）"><a href="#1-3微分控制算法（微分因子Kd）" class="headerlink" title="1.3微分控制算法（微分因子Kd）"></a>1.3微分控制算法（微分因子Kd）</h3><p>换一个另外的例子，考虑刹车情况。平稳的驾驶车辆，当发现前面有红灯时，为了使得行车平稳，基本上提前几十米就放松油门并踩刹车了。当车辆离停车线非常近的时候，则使劲踩刹车，使车辆停下来。整个过程可以看做一个加入微分的控制策略。<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1589388560122&di=22500c1b177219cba812c89f8e96df07&imgtype=0&src=http%3A%2F%2Fimage.bitautoimg.com%2Fappimage-630-w0%2Fappimage%2Fmedia%2F20160819%2Fw507_h203_4f1fb584594948aab81c2f3c55fabde2.jpeg" alt><br>微分，说白了在离散情况下，就是error的差值，就是t时刻和t-1时刻error的差,即：</p>
<center>u=kd*（error（t）-error（t-1））</center>

<p>其中的kd是一个系数项。可以看到，在刹车过程中，因为error是越来越小的，所以这个微分控制项一定是负数，在控制中加入一个负数项，他存在的作用就是为了防止汽车由于刹车不及时而闯过了线。从常识上可以理解，越是靠近停车线，越是应该注意踩刹车，不能让车过线，所以这个微分项的作用，就可以理解为刹车，当车离停车线很近并且车速还很快时，这个微分项的绝对值（实际上是一个负数）就会很大，从而表示应该用力踩刹车才能让车停下来。</p>
<p>切换到上面给水缸加水的例子，就是当发现水缸里的水快要接近1的时候，加入微分项，可以防止给水缸里的水加到超过1米的高度，说白了就是减少控制过程中的震荡。</p>
<h2 id="02照本宣科谈PID"><a href="#02照本宣科谈PID" class="headerlink" title="02照本宣科谈PID"></a>02照本宣科谈PID</h2><h3 id="2-1-PID算法的前提"><a href="#2-1-PID算法的前提" class="headerlink" title="2.1 PID算法的前提"></a>2.1 PID算法的前提</h3><p>PID是一个闭环控制算法。因此要实现PID算法，必须在硬件上具有闭环控制，就是得有反馈。</p>
<h3 id="2-2-使用现状"><a href="#2-2-使用现状" class="headerlink" title="2.2 使用现状"></a>2.2 使用现状</h3><p>PID是比例(P)、积分(I)、微分(D)控制算法。但并不是必须同时具备这三种算法，也可以是PD,PI,甚至只有P算法控制。我以前对于闭环控制的一个最朴素的想法就只有P控制，将当前结果反馈回来，再与目标相减，为正的话，就减速，为负的话就加速。现在知道这只是最简单的闭环控制算法。</p>
<h3 id="2-3三个环节的作用"><a href="#2-3三个环节的作用" class="headerlink" title="2.3三个环节的作用"></a>2.3三个环节的作用</h3><ol>
<li><p>比例，反应系统的基本（当前）偏差e(t)，系数大，可以加快调节，减小误差，但过大的比例使系统稳定性下降，甚至造成系统不稳定；</p>
</li>
<li><p>积分，反应系统的累计偏差，使系统消除稳态误差，提高无差度，因为有误差，积分调节就进行，直至无误差。</p>
</li>
<li><p>微分，反映系统偏差信号的变化率e(t)-e(t-1)，具有预见性，能预见偏差变化的趋势，产生超前的控制作用，在偏差还没有形成之前，已被微分调节作用消除，因此可以改善系统的动态性能。但是微分对噪声干扰有放大作用，加强微分对系统抗干扰不利。</p>
<h3 id="2-4常用的调参经验-使用规律"><a href="#2-4常用的调参经验-使用规律" class="headerlink" title="2.4常用的调参经验(使用规律)"></a>2.4常用的调参经验(使用规律)</h3></li>
<li><p>比例控制规律P：采用P控制规律能较快地克服扰动的影响，它的作用于输出值较快，但不能很好稳定在一个理想的数值，不良的结果是虽较能有效的克服扰动的影响，但有余差出现。它适用于控制通道滞后较小、负荷变化不大、控制要求不高、被控参数允许在一定范围内有余差的场合。</p>
</li>
</ol>
<ol start="2">
<li><p>比例积分控制规律(PI)：在工程中比例积分控制规律是应用最广泛的一种控制规律。积分能在比例的基础上消除余差，它适用于控制通道滞后较小、负荷变化不大、被控参数不允许有余差的场合。</p>
</li>
<li><p>比例微分控制规律(PD)：微分具有超前作用，对于具有容量滞后的控制通道，引入微分参与控制，在微分项设置得当的情况下，对于提高系统的动态性能指标，有着显著效果。因此，对于控制通道的时间常数或容量滞后较大的场合，为了提高系统的稳定性，减小动态偏差等可选用比例微分控制规律。如：加热型温度控制、成分控制。需要说明一点，对于那些纯滞后较大的区域里，微分项是无能为力，而在测量信号有噪声或周期性振动的系统，则也不宜采用微分控制。</p>
</li>
<li><p>例积分微分控制规律(PID)：PID控制规律是一种较理想的控制规律，它在比例的基础上引入积分，可以消除余差，再加入微分作用，又能提高系统的稳定性。</p>
</li>
</ol>
<p>总之，控制规律的选用要根据过程特性和工艺要求来选取，决不是说PID控制规律在任何情况下都具有较好的控制性能，不分场合都采用是不明智的。如果这样做，只会给其它工作增加复杂性，并给参数整定带来困难。当采用PID控制器还达不到工艺要求，则需要考虑其它的控制方案。如串级控制、前馈控制、大滞后控制等。</p>
<h2 id="03PID-控制器的设计与实现"><a href="#03PID-控制器的设计与实现" class="headerlink" title="03PID 控制器的设计与实现"></a>03PID 控制器的设计与实现</h2><h3 id="3-1PID算法的推导"><a href="#3-1PID算法的推导" class="headerlink" title="3.1PID算法的推导"></a>3.1PID算法的推导</h3><p>连续时间PID控制系统图如下图所示。其中D(s)为PID控制器部分，其输入与输出的的关系可按照下面的微分方程表示：</p>
<p><a href="https://pic.downk.cc/item/5ebbf661c2a9a83be56e20e8.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ebbf661c2a9a83be56e20e8.jpg" alt></a></p>
<p><a href="https://pic.downk.cc/item/5ebbf5d4c2a9a83be56da35a.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ebbf5d4c2a9a83be56da35a.jpg" alt></a></p>
<p>在数字控制器中，当采样周期足够短时，以求和代替积分，以差分代替微分。则k时刻与k-1时刻的微分方程可分别表达为下面形式</p>
<p><a href="https://pic.downk.cc/item/5ebbf690c2a9a83be56e4d32.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ebbf690c2a9a83be56e4d32.jpg" alt></a></p>
<p>两式相减</p>
<p><a href="https://pic.downk.cc/item/5ebbf6bac2a9a83be56e7ab8.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ebbf6bac2a9a83be56e7ab8.jpg" alt></a></p>
<p><strong>这就是数字PID控制器的增量式算法。</strong></p>
<p>假设需要辨识的被控对象模型为</p>
<p><a href="https://pic.downk.cc/item/5ebbf6fcc2a9a83be56ec39f.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ebbf6fcc2a9a83be56ec39f.jpg" alt></a></p>
<h3 id="3-2Matlab编程实现"><a href="#3-2Matlab编程实现" class="headerlink" title="3.2Matlab编程实现"></a>3.2Matlab编程实现</h3><ol>
<li>因为要建立起系统离散差分模型，先用matlab确定系统的离散模型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clear</span>;</span><br><span class="line">clc;</span><br><span class="line">ts=<span class="number">0.5</span>; </span><br><span class="line">sys=tf(<span class="number">4</span>,[<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>]);%系统的传递函数</span><br><span class="line">dsys=c2d(sys,ts,<span class="string">'z'</span>);%离散化</span><br><span class="line">[num,den]=tfdata(dsys,<span class="string">'v'</span>);%得到离散化后的z传递函数分子分母系数</span><br></pre></td></tr></table></figure></li>
<li>程序运行的结果如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sys =</span><br><span class="line">      <span class="number">4</span></span><br><span class="line">  ---------</span><br><span class="line">  s^<span class="number">2</span> + <span class="number">2</span> s</span><br><span class="line">Continuous-time <span class="built_in">transfer</span> function.</span><br><span class="line">dsys =</span><br><span class="line">    <span class="number">0.3679</span> z + <span class="number">0.2642</span></span><br><span class="line">  ----------------------</span><br><span class="line">  z^<span class="number">2</span> - <span class="number">1.368</span> z + <span class="number">0.3679</span></span><br><span class="line">Sample time: <span class="number">0.5</span> seconds</span><br><span class="line">Discrete-time <span class="built_in">transfer</span> function.</span><br></pre></td></tr></table></figure></li>
<li>系统的差分方程如下</li>
</ol>
<center>y(k)=-1*den(3)*y_2-den(2)*y_1+num(3)*u_2+num(2)*u_1+num(1)*u(k)</center>

<ol start="4">
<li>完整的程序实现<figure class="highlight"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">title:PID 控制算法实现</span><br><span class="line">date: <span class="number">2020.05</span><span class="number">.10</span></span><br><span class="line">author:Decaplee</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>;</span><br><span class="line">clc;</span><br><span class="line">ts=<span class="number">0.5</span>;  %采样时间=<span class="number">0.5</span>s</span><br><span class="line">sys=tf(<span class="number">4</span>,[<span class="number">1</span> <span class="number">2</span> <span class="number">0</span>]);%建立被控对象传递函数</span><br><span class="line">dsys=c2d(sys,ts,<span class="string">'z'</span>);%离散化,表示为z传递函数的形式</span><br><span class="line">[num,den]=tfdata(dsys,<span class="string">'v'</span>);%输出num和den，分别代表差分方程分子与分母的系数</span><br><span class="line">e_1=<span class="number">0</span>;      %初始化k<span class="number">-1</span>、k<span class="number">-2</span>时刻的偏差</span><br><span class="line">e_2=<span class="number">0</span>;</span><br><span class="line">u_1=<span class="number">0.0</span>;    %初始化k<span class="number">-1</span>、k<span class="number">-2</span>时刻时刻的输入量</span><br><span class="line">u_2=<span class="number">0.0</span>;</span><br><span class="line">y_1=<span class="number">0</span>;      %初始化k<span class="number">-1</span>、k<span class="number">-2</span>时刻时刻的输出量</span><br><span class="line">y_2=<span class="number">0</span>;</span><br><span class="line">Esum=<span class="number">0</span>;</span><br><span class="line">%PID参数</span><br><span class="line">kp=<span class="number">2.1</span>;    </span><br><span class="line">ki=<span class="number">0.3</span></span><br><span class="line">kd=<span class="number">0.12</span>;</span><br><span class="line">u=zeros(<span class="number">1</span>,<span class="number">100</span>);%数组的大小</span><br><span class="line">time=zeros(<span class="number">1</span>,<span class="number">100</span>);%初始化数组的大小</span><br><span class="line">ts=<span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="number">1</span>:<span class="number">100</span></span><br><span class="line">    time(k)=k*ts;   %时间参数由 <span class="number">1</span> 时刻开始</span><br><span class="line">    r(k)=<span class="number">1</span>;      %期望值</span><br><span class="line">    y(k)=<span class="number">-1</span>*den(<span class="number">3</span>)*y_2-den(<span class="number">2</span>)*y_1+num(<span class="number">3</span>)*u_2+num(<span class="number">2</span>)*u_1+num(<span class="number">1</span>)*u(k);% 初始化系统响应输出序列，与前一时刻的输出有关（这就是差分方程）</span><br><span class="line">    e(k)=r(k)-y(k);   %期望输出与实际输出之间的差值，代表误差信号</span><br><span class="line">    u(k)=kp*(e(k)-e_1)+ki*e(k)+kd*(e(k)<span class="number">-2</span>*e_1+e_2); %系统PID控制器输出序列</span><br><span class="line">    u_2=u_1;</span><br><span class="line">    y_2=y_1;</span><br><span class="line">    e_2=e_1;</span><br><span class="line">    u_1=u(k);    	%前一个的控制器输出值</span><br><span class="line">    y_1=y(k);    	%前一个的系统响应输出值</span><br><span class="line">    e_1=e(k);      %前一个误差信号的值</span><br><span class="line"><span class="built_in">end</span></span><br><span class="line">p1=plot(time,r,'-.');xlim([0,50]);hold on;%指令信号的曲线（即期望输入）</span><br><span class="line">p2=plot(time,y,'b--');xlim([0,50]);hold on;%</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>当Kp=2.1、Ki=0.3、Kd=0.12时，输出的控制曲线如下<br><a href="https://pic.downk.cc/item/5ebbf8f5c2a9a83be570c528.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ebbf8f5c2a9a83be570c528.jpg" alt></a></p>
<h2 id="04-PID控制器参数整定"><a href="#04-PID控制器参数整定" class="headerlink" title="04 PID控制器参数整定"></a>04 PID控制器参数整定</h2><h3 id="4-1-参数整定过程"><a href="#4-1-参数整定过程" class="headerlink" title="4.1 参数整定过程"></a>4.1 参数整定过程</h3><p>在进行参数整定之前，笔者利用Matlab的GUI模块建立了数字PID参数整定系统，便于观察PID控制器各个环节的参数对系统响应性能的影响，如设计布局和实际运行效果分别如下图所示<br><a href="https://pic.downk.cc/item/5ebbf972c2a9a83be5714732.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ebbf972c2a9a83be5714732.jpg" alt></a></p>
<p>下面采用扩充临界比例度法进行参数整定：</p>
<p>扩充临界比例度法适用于有自衡特性的受控对象，是对连续时间PID控制器参数整定的临界比例度的扩充，其主要步骤如下：</p>
<ol>
<li><p>选择一足够短的采样周期T(一般应在被控对象纯时延时间的十分之一以下)，作纯比例控制。</p>
</li>
<li><p>逐渐加大比例系数Kp，直到系统达到临界等幅振荡，记下此时的振荡周期Ts，以及增益Ks。</p>
</li>
<li><p>选择控制度</p>
</li>
</ol>
<blockquote>
<p>所谓控制度，就是以模拟控制器为标准，将数字控制器的效果与模拟控制器的控制效果相比较，通常采用误差积分的比值形式进行定义，即</p>
</blockquote>
<p><a href="https://pic.downk.cc/item/5ebbfa24c2a9a83be57208a6.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ebbfa24c2a9a83be57208a6.jpg" alt></a></p>
<ol start="4">
<li><p>4)根据选定的控制度，查表，确定PID控制器的采样周期T和控制器参数Kp, TI, TI 。</p>
</li>
<li><p>5)按照求得的整定参数试运行，观察实际控制效果，并适当进行修正。</p>
</li>
</ol>
<h3 id="4-2-参数整定结果"><a href="#4-2-参数整定结果" class="headerlink" title="4.2 参数整定结果"></a>4.2 参数整定结果</h3><p>经过多次参数调整分析，并利用Matlab的GUI模块综合考虑上升时间，超调量，稳态时间，稳态误差等因素，在下图的GUI中观察参数整定效果。<br><a href="https://pic.downk.cc/item/5ebbfa7dc2a9a83be5726f78.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ebbfa7dc2a9a83be5726f78.jpg" alt></a></p>
<p>最终整定结果为</p>
<center>K_P=0.65&emsp;&emsp;&emsp; K_I=0.6 &emsp;&emsp;&emsp;        K_D=0 </center>

<p>整定后的输出响应曲线为</p>
<p><a href="https://pic.downk.cc/item/5ebbfaf2c2a9a83be572f251.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5ebbfaf2c2a9a83be572f251.jpg" alt></a></p>
<p>可见，经过参数整定后系统的上升时间超调量以及稳态误差的整体控制效果有了巨大的改进。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://book.douban.com/subject/3194654/" target="_blank" rel="noopener">参考文献一</a></p>
<p><a href="https://blog.csdn.net/lukelu1263/article/details/6847208?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">参考文献二</a></p>
<p><a href="https://blog.csdn.net/qq_25352981/article/details/81007075" target="_blank" rel="noopener">参考文献三</a></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://github.com/DecaprioTesla/Digital_PID_Controler" target="_blank" rel="noopener">PID调参界面源码已上传至我的GitHub</a></p>
]]></content>
      <categories>
        <category>控制</category>
      </categories>
  </entry>
  <entry>
    <title>转知乎：历史上的七次机会</title>
    <url>/2020/05/10/017%E8%BD%AC%E8%87%AA%E7%9F%A5%E4%B9%8E%EF%BC%9A%E5%8E%86%E5%8F%B2%E4%B8%AD%E7%9A%84%E6%9C%BA%E4%BC%9A/</url>
    <content><![CDATA[<p>&emsp;&emsp;最近在看赵皓阳的《生而贫穷》，作者在书中鲜明地提出了社会层次的本质以及发展到一定程度后将达到的现状：贫者难以脱贫，富者愈发积累，也就是所谓的阶级固化这一现象，同时也用一个金字塔模型来反映社会的分层。<br><img src="https://s1.ax1x.com/2020/05/12/YNAxmj.png" alt="YNAxmj.png"><br>&emsp;&emsp;书中还提到一种观点：一个人的人生高度，或者所谓的世俗意义上的成功，宏观上是由多个因素决定的，相关性最大的是家族、传承、基因等；其次是时势，也就是我们所处的历史进程；最后才是个人的奋斗与拼搏。恰巧今天又在知乎上看到一篇关于时势的文章，非常呼应解释第二点，原文的标题为《历史上七次机会没有留给普通人》。</p>
<a id="more"></a>
<center>

<h2 id="历史上七次机会没有留给普通人"><a href="#历史上七次机会没有留给普通人" class="headerlink" title="历史上七次机会没有留给普通人"></a>历史上七次机会没有留给普通人</h2></center>

<ul>
<li>第一次是78年的高考；</li>
</ul>
<p>1977年到79年，100万考生步入大学的殿堂，从此改变命运，但也仅仅是100万。而且这100万人当中又有多少是出身贫寒，真正改变阶级的呢？更多的学位还是留给了拥有政治资本的官二代。当年的高考顶替上大学的事情层出不穷，沦为炮灰的不过是那些没背景没钱的普通子弟吧。</p>
<ul>
<li>第二次是80年乡镇企业；</li>
</ul>
<p>乡镇企业兴起是所谓改革开放的意外收获，国家也没想到偏远的农村会是改革开放最有活力的地区。新希望集团的刘永好兄弟、华西村的吴仁宝、横店集团的徐文荣、福耀玻璃的曹德旺、温氏集团的温北英······我们耳熟能详的名字是那个时代企业家的代表。这是中国历史上，唯一一次农民群体大规模“由农入商”，可能也是最后一次。</p>
<ul>
<li>第三次是价格双轨制的套利，就是倒买倒卖；</li>
</ul>
<p>那些倒爷们利用手中的关系，用计划内的低价购买商品，再用计划外的市场价卖出</p>
<ul>
<li><p>第四次是92年的官员下海，就是潘石屹那一代；</p>
</li>
<li><p>第五次叫做资源狂潮，就是WTO的红利，煤老板和钢老板发财；</p>
</li>
</ul>
<p>那些处于体制内的官员“春江水暖鸭先知”，利用手中关系下海经商积累财富改变阶级。此时此刻，中国大地数以亿计的农民和即将下岗的国企工人还没看到这些机会，就算看到了，不具备政治资本和知识资本也没成功的希望。</p>
<p>资源狂潮中我们认识了那些煤老板，他们是做生意最真诚的一批人，除了女明星他们什么也不在乎。</p>
<ul>
<li>第六次是地产泡沫，05年以后房价的暴涨；</li>
</ul>
<p>房地产泡沫应该是离我们最近的一次机会了，这是最普惠的一次机会，就算是普通家庭也能贷款买套房，但是离改变命运还差的远。那些没来的及上车的普通家庭，就彻底沦为贫困阶级，现在一套房可以压垮一个家庭。能在这次房地产泡沫中赚的盆满钵满的还是那些温州炒房团和煤老板们，他们分别受益于上世纪80年代乡镇企业崛起和本世纪初的资源狂潮。房地产催生了一批富豪，却摧毁了更多的家庭，80后、90后成为房奴艰苦度日，透支未来的潜力。</p>
<p>改变命运的机会永远都在，作为普通人我们却抓不住。我知道尽管过去四十年中国人的生活得到了翻天覆地的变化，但大多数人在社会中的相对位置其实并没有改变。</p>
<ul>
<li>第七次是网络福利，也就是腾讯和阿里的故事。</li>
</ul>
<p>这七次机会每一次都很给力，每一次都波澜壮阔，但是我没觉得这七次机会哪一次是留给普通人的。</p>
<p>我庆幸受到高等教育，能坐在廉价的写字楼里办公，不受风吹雨打。但是与我那些在车间做普工的小学同学对比，其实我们还是一类人。人改善生活际遇不难，但要改变在社会里的相对位置，几千年来都是一项艰巨的修行。</p>
<p>机会还很多，没来的及上车的已经上不了车，因为座位已经被上一次上车的人占据了。</p>
<p>普通人改善生活际遇不难，但要改变在社会里的相对位置，需要借助时代的力量。阶级向上的通道永远都是敞开的，但只对少数人敞开，这些人一定要有勇于做关键选择的睿智，敢于告别舒适的魄力，面对失败不言弃的毅力。 </p>
<blockquote>
<p>以上内容转自知乎</p>
</blockquote>
<hr>
<p>再回到《生而贫穷》这本书，开头说了个人发展的三个因素，真正看清这些的人恰恰反而不会消极接受命运的安排，因为他们知道第一条几乎没法选择，第二条需要宏大的战略眼光甚至更多的是运气，能够努力改变的只有第三条。</p>
<p>但现实中，大多数人最开始都盲目信任第三条的力量，碰壁后又掉头完全信仰第一、第二条——他们最终变成了自己曾经讨厌的那类人。</p>
<p>真正看清楚并做出选择，需要五味杂陈的生活的磨练和自身的改变。</p>
<p>社会就是这样，需要我们每个人努力将自己和他人变得更好，生命对每个人来说都是最大的奢侈品。</p>
<p>我们都是后浪，有些后浪有海风相伴，有些后浪面前尽是礁石暗滩…但不论怎样，别忘记奔涌。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>社会</tag>
        <tag>时代</tag>
      </tags>
  </entry>
  <entry>
    <title>Next主题添加标签云</title>
    <url>/2020/05/05/015Next%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E6%A0%87%E7%AD%BE%E4%BA%91/</url>
    <content><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588684105534&di=85bd6c3c479d903c274f9efa39e2d754&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20181112%2F086d7399d6f847b29d9af111aca77a68.jpeg" alt></p>
<center>在Next主题下添加标签云</center>

<a id="more"></a>
<h2 id="一、Hexo-Tag-Cloud标签云介绍"><a href="#一、Hexo-Tag-Cloud标签云介绍" class="headerlink" title="一、Hexo-Tag-Cloud标签云介绍"></a>一、Hexo-Tag-Cloud标签云介绍</h2><p>hexo-tag-cloud插件是github上某位大佬写的一个Hexo博客的标签云插件，旨在直观的展示标签的种类，美观大方且非常优雅。</p>
<ul>
<li>插件地址：<br><a href="https://github.com/MikeCoder/hexo-tag-cloud" target="_blank" rel="noopener">插件的Github地址</a></li>
<li>插件的说明:<br><a href="https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md" target="_blank" rel="noopener">插件介绍</a></li>
</ul>
<h2 id="二、插件安装方法"><a href="#二、插件安装方法" class="headerlink" title="二、插件安装方法"></a>二、插件安装方法</h2><p>进入到 hexo 的根目录，在 package.json 中添加依赖: </p>
<p>“hexo-tag-cloud”: “2.0.*” 操作如下：</p>
<h3 id="1、使用如下命令安装插件："><a href="#1、使用如下命令安装插件：" class="headerlink" title="1、使用如下命令安装插件："></a>1、使用如下命令安装插件：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">npm install hexo-tag-cloud@^<span class="number">2.0</span>.* --save</span><br></pre></td></tr></table></figure>
<p>插件的配置需要对应的环境，可以在主题文件夹里找一下，有没有对应的渲染文件，然后根据渲染文件的类型，选择对应的插件配置方法。</p>
<h3 id="2、配置插件"><a href="#2、配置插件" class="headerlink" title="2、配置插件"></a>2、配置插件</h3><p>(1) 在主题文件夹找到文件 <code>theme/next/layout/_macro/sidebar.swig</code>, 然后添加如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;% <span class="keyword">if</span> site.tags.length &gt; <span class="number">1</span> %&#125;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span> src=<span class="string">"/js/tagcloud.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> charset=<span class="string">"utf-8"</span> src=<span class="string">"/js/tagcanvas.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;div class=<span class="string">"widget-wrap"</span>&gt;</span><br><span class="line">    &lt;h3 class=<span class="string">"widget-title"</span>&gt;Tag Cloud&lt;/h3&gt;</span><br><span class="line">    &lt;div id=<span class="string">"myCanvasContainer"</span> class=<span class="string">"widget tagcloud"</span>&gt;</span><br><span class="line">        &lt;canvas width=<span class="string">"250"</span> height=<span class="string">"250"</span> id=<span class="string">"resCanvas"</span> style=<span class="string">"width=100%"</span>&gt;</span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        &lt;/canvas&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>代码添加到后面即可，添加示意图如下:<br><img src="https://img-blog.nos-eastchina1.126.net/blog/hexo_tag_cloud_code.jpg" alt></p>
<h3 id="3、主题配置"><a href="#3、主题配置" class="headerlink" title="3、主题配置"></a>3、主题配置</h3><p>在博客根目录，找到 _config.yml配置文件然后在最后添加如下的配置项，可以自定义标签云的字体和颜色，还有突出高亮:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># hexo-tag-cloud</span></span><br><span class="line">tag_cloud:</span><br><span class="line">    textFont: Trebuchet MS, Helvetica</span><br><span class="line">    textColor: '#333'</span><br><span class="line">    textHeight: <span class="number">25</span></span><br><span class="line">    outlineColor: '#E2E1D1'</span><br><span class="line">    maxSpeed: <span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>textColor: ‘#333’ 字体颜色</li>
<li>textHeight: 25 字体高度，根据部署的效果调整</li>
<li>maxSpeed: 0.1 文字滚动速度，根据自己喜好调整</li>
</ul>
<h2 id="三、效果语言"><a href="#三、效果语言" class="headerlink" title="三、效果语言"></a>三、效果语言</h2><p>在git中输入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>
<h2 id="四、博客部署"><a href="#四、博客部署" class="headerlink" title="四、博客部署"></a>四、博客部署</h2><p>博客部署，在git中输入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>推荐使用 &amp;&amp; 作为组合命令的串联符号</p>
<p>注：一定要严格清理缓存，这样不容易出现问题，即需要执行hexo clean</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://github.com/MikeCoder/hexo-tag-cloud/blob/master/README.ZH.md" target="_blank" rel="noopener">参考文献一</a></p>
<p><a href="https://blog.csdn.net/DreamHome_S/article/details/78250692" target="_blank" rel="noopener">参考文献二</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>标签云</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows系统下基于putty+VNC与树莓派4B连接</title>
    <url>/2020/03/16/010%E6%A0%91%E8%8E%93%E6%B4%BEpuutty/</url>
    <content><![CDATA[<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584371094015&di=f0d8c4fd96aee78cbf386c55e872a9fe&imgtype=0&src=http%3A%2F%2Fmp.ofweek.com%2Fdata%2Fimages%2Fpchome%2F2020-02-28%2F7d77ace6438ab259e5c897ba265229f4.png" alt="image.png"></p>
<a id="more"></a>
<p>&ensp;&ensp;去年12月份花了500多大洋入手了一个树莓派4B，顶配的4GB RAM.当时想着是学习一下Linux系统，并基于树莓派进行一些DIY开发。这块板子刚取到后我就去听了学校的大师论坛讲座，那天的汇报人是数学界大佬丘成桐，讲座结束之后有幸要到了大佬在我的包装盒上的签名。</p>
<p><img src="https://i.loli.net/2020/03/16/IVSyBa5tXJpmfWj.png" alt="image.png"></p>
<p>&ensp;&ensp;但是，自从买回来之后这块树莓派就一直放在那里吃灰，期间试着在无显示屏的情况下进行连接。今天整理物品时将其找了出来，想着干脆学学这玩意儿。下面就先介绍无显示屏情况下进入树莓派系统的方法。</p>
<h2 id="00准备工作"><a href="#00准备工作" class="headerlink" title="00准备工作"></a>00准备工作</h2><blockquote>
<p>设备：<strong>树莓派裸板</strong>、<strong>网线</strong>、<strong>笔记本</strong></p>
</blockquote>
<blockquote>
<p>软件：</p>
</blockquote>
<blockquote>
<p><strong>putty</strong>(<a href="https://putty.en.softonic.com/" target="_blank" rel="noopener">https://putty.en.softonic.com/</a>)<br><strong>VNCViewer</strong>(<a href="https://www.realvnc.com/en/connect/download/viewer/)。" target="_blank" rel="noopener">https://www.realvnc.com/en/connect/download/viewer/)。</a></p>
</blockquote>
<p>&ensp;&ensp;两款软件均为开源免费，下载后无脑安装。</p>
<h2 id="01、将WLAN设置为共享模式"><a href="#01、将WLAN设置为共享模式" class="headerlink" title="01、将WLAN设置为共享模式"></a>01、将WLAN设置为共享模式</h2><p>&ensp;&ensp;首先将利用网线将树莓派和笔记本的网口连接起来,然后进入WIndows的设置中心,选择进入网络和Internet设置.左边选择WLAN右边选择更改适配器选项<img src="https://i.loli.net/2020/03/16/pjkzNIStJoOPcmf.png" alt="image.png"></p>
<p>&ensp;&ensp;接着进入网络连接设置选项,右键WALN,选择属性,进入属性设置界面.</p>
<p><img src="https://i.loli.net/2020/03/16/qaRXFCD36Z2WpkT.png" alt="image.png"></p>
<p>&ensp;&ensp;然后选择上方的共享,勾选两个选框,家庭网络连接选择以太网,点击确定,此时会发现WLAN的名称后面多了:”共享的”三个字。</p>
<p><img src="https://i.loli.net/2020/03/16/E25NJFjiTfQGZzq.png" alt="image.png"></p>
<h2 id="02-利用命令提示符查询树莓派的IP"><a href="#02-利用命令提示符查询树莓派的IP" class="headerlink" title="02 利用命令提示符查询树莓派的IP"></a>02 利用命令提示符查询树莓派的IP</h2><p>&ensp;&ensp;Win+R 快捷方式进入命令提示符窗口,然后输入:arp -a,找到192.168.137.1IP地址下的第一个IP,(我的为192.168.137.9)此IP为主机为树莓派分配的一个IP,然后打开Putty,输入刚才的IP地址后点击Open既可以。</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YZ1m9.png" alt="8YZ1m9.png"></p>
<h2 id="03-Putty连接至树莓派"><a href="#03-Putty连接至树莓派" class="headerlink" title="03 Putty连接至树莓派"></a>03 Putty连接至树莓派</h2><p>&ensp;&ensp;putty中输入树莓派分配到的IP:</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YQ9Nd.png" alt="8YQ9Nd.png"></p>
<p>&ensp;&ensp;接着就会进入到树莓派的登录界面:用户名默认是:pi,默认的密码是:raspberry.在输入密码时不会显示密码,输入完成后点击Enter键即可,如下图所示:</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YMkmF.png" alt="8YMkmF.png"></p>
<p>&ensp;&ensp;熟悉Linux的童鞋们到此步就可以在树莓派的Linux系统下尽情徜徉了,但对于我等刚入门者还需要一个UI界面比较容易接收和学习,下面介绍如何利用VNC来实现树莓派系统的UI界面.</p>
<h2 id="04开启VNC功能-实现树莓派的UI界面"><a href="#04开启VNC功能-实现树莓派的UI界面" class="headerlink" title="04开启VNC功能,实现树莓派的UI界面"></a>04开启VNC功能,实现树莓派的UI界面</h2><p>&ensp;&ensp;在上图的命令窗口中输入vncserver,开启VNC功能</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vncserver</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/16/8YMClV.png" alt="8YMClV.png"></p>
<p>&ensp;&ensp;然后打开VNCViewer,再次输入主机为树莓派分配的IP然后弹出如下界面就代表连接成功</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YKoWt.png" alt="8YKoWt.png"></p>
<p>&ensp;&ensp;点击Continue,默认的登录密码是raspberry,输入密码后点击OK</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YMtfI.png" alt="8YMtfI.png"></p>
<p>&ensp;&ensp;Congratulations!,现在你可以开启你的树莓派的学习之旅了</p>
<p><img src="https://s1.ax1x.com/2020/03/16/8YMXjK.png" alt="8YMXjK.png"></p>
<h2 id="05写在后面"><a href="#05写在后面" class="headerlink" title="05写在后面"></a>05写在后面</h2><p>&ensp;&ensp;虽然网上可以买到树莓派的显示屏,或者直接找一台显示屏通过HDMI接口即可作为树莓派的显示屏,但上述两种选择对我来说完全没有必要,单独购买显示屏需要另外花钱不说,给其配一台显示器导致其便携性下降.所以,直接利用自己的笔记本来当显示屏是一个非常好的选择.</p>
<p>&ensp;&ensp;作为卡片电脑,树莓派的功能十分强大,学习其GPIO口基本上可以将其当做一块微控制器来玩.另外其具有无线模块,在油管上看到有将树莓派当作软路由的教程,呵呵,搭一个路由器,全宿舍,全家科学上网,岂不美哉!!!</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>VNC</tag>
      </tags>
  </entry>
  <entry>
    <title>Git将本地文件上传至Github仓库</title>
    <url>/2020/03/10/009git%E5%B7%A5%E5%85%B7%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E8%87%B3github%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>🖨️使用git工具将本地文件上传至项目托管平台，方便自己对项目进行日常的更新管理以及实现项目的共享，下面简要介绍一些步骤：</p>
<a id="more"></a>
<h1 id="📌git工具上传本地文件项目至github远程仓库"><a href="#📌git工具上传本地文件项目至github远程仓库" class="headerlink" title="📌git工具上传本地文件项目至github远程仓库"></a>📌git工具上传本地文件项目至github远程仓库</h1><ol>
<li>📎在Github上新建一个仓库，并命名</li>
<li>📎在本地文件下下右键，选择GitBash Here打开git工具</li>
<li>📎命令行中首先输入：git init  (然后可以利用ls语句来检查一下项目文件下的所有文件)</li>
<li>📎输入：git add .   然后回车</li>
<li>📎输入：git commit -m’对项目的说明’</li>
<li>📎然后输入：git remote add origin <a href="https://github.com/DecaprioTesla/Tempure_measure.git" target="_blank" rel="noopener">https://github.com/DecaprioTesla/Tempure_measure.git</a>  （网址为Github仓库分配的网页）</li>
<li>📎最后输入： git push -u origin master (首次使用可能需要输入用户名和密码)</li>
</ol>
<h1 id="📌本地项目做修改后重新上传至github远程仓库"><a href="#📌本地项目做修改后重新上传至github远程仓库" class="headerlink" title="📌本地项目做修改后重新上传至github远程仓库"></a>📌本地项目做修改后重新上传至github远程仓库</h1><ol>
<li>📎对本地文件做一定的修改，加入新的文件等等</li>
<li>📎记住所作修改或添加的文件，然后：git add 修改的文件名称.格式</li>
<li>📎输入：git commit -m’添加修改说明’</li>
<li>📎输入：git pull –rebase origin master</li>
<li>📎最后输入 git push -u origin master上传修改或添加的文件的文件</li>
</ol>
]]></content>
      <categories>
        <category>技术理论</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>胡适日记</title>
    <url>/2020/03/08/008%E8%83%A1%E9%80%82%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<center><font face="黑体" color="black" size="5">颓废日记全篇</font></center>

<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583688617647&di=679b46139e9339467bbb1e2d28603249&imgtype=0&src=http%3A%2F%2Fimg1.gtimg.com%2Fninja%2F1%2F2019%2F05%2Fninja155694486387376.png" alt="图"></p>
<a id="more"></a>
<center><font face="黑体" color="black" size="4">打牌日记</font></center>

<blockquote>
<p>七月二日：天热不能作事，打牌消遣；</p>
</blockquote>
<blockquote>
<p>七月三日：今日天气百一十度。打牌。</p>
</blockquote>
<blockquote>
<p>七月五日：往暑期学校注册。打牌。</p>
</blockquote>
<blockquote>
<p>七月六日：暑期学校注册，化学。打牌。</p>
</blockquote>
<blockquote>
<p>七月七日：上课，打牌。</p>
</blockquote>
<blockquote>
<p>七月八日：无课，打牌，天作稍凉矣。</p>
</blockquote>
<blockquote>
<p>七月廿一日：化学第二小测试……打牌。</p>
</blockquote>
<blockquote>
<p>七月廿二日：打牌，读美国短篇名著数种。</p>
</blockquote>
<blockquote>
<p>七月廿四日：上课，得意争一书，打牌，演化学算题</p>
</blockquote>
<blockquote>
<p>七月廿五日：上课，作书复德争。打牌。</p>
</blockquote>
<p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2933670769,1198485342&fm=26&gp=0.jpg" alt="图"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>划水</tag>
      </tags>
  </entry>
  <entry>
    <title>自适应控制（二）</title>
    <url>/2020/03/07/007%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%E8%87%AA%E6%A0%A1%E6%AD%A3%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="基于优化策略自校正控制器"><a href="#基于优化策略自校正控制器" class="headerlink" title="基于优化策略自校正控制器"></a>基于优化策略自校正控制器</h1><p>&emsp;&emsp;几十年来，常规的PID控制器的研究，不论是在理论还是实践上都作了大量的工作，因而被应用于各种过程控制，并得到了良好的效果。随着科学技术的发展人们对控制的系统的要求越来越高，特别是那些被控参数是未知或存在参数变化或不确定扰动的控制过程，想要取得良好的控制效果，就必须进行在线调节控制器得参数。但是想要对PID控制器进行在线参数调节是十分困难的。如果采用自校正技术就可以自动调节调节器或控制参数，使系统在较好的性能下运行。</p>
<a id="more"></a>
<h2 id="1-最小方差控制"><a href="#1-最小方差控制" class="headerlink" title="1.最小方差控制"></a>1.最小方差控制</h2><h3 id="1-1提出"><a href="#1-1提出" class="headerlink" title="1.1提出"></a>1.1提出</h3><p>&emsp;&emsp;最小方差控制的概念（Self-tuning Regulators，自校正调节器）最初由Åström等人在1973年提出。目的是最大限度地减小干扰对系统的影响。</p>
<h3 id="1-2最小方差的思想"><a href="#1-2最小方差的思想" class="headerlink" title="1.2最小方差的思想"></a>1.2最小方差的思想</h3><p>&emsp;&emsp;通过保证包含输出的某一随机变量的方差取最小来设计当前时刻的控制量𝑢(𝑘)。为此，必须使得系统输出中包含当前时刻的控制量。假设被控对象或过程存在𝑑步的纯延时，那么当前时刻的控制作用𝑢(𝑘)要滞后𝑑个采样周期才能在输出中体现出来，这样我们可以选择并通过保证包含输出𝑦(𝑘 + 𝑑)的某一变量的方差最小来设计当前时刻的控制量。设计过程中，借助输出量的预测信息计算出当前时刻的控制量。当过程参数未知或时变时先用递推最小二乘法估计相应的参数，或直接估计控制器参数，然后算出𝑢(𝑘)。这样，通过连续不断地进行预测和控制，就能始终保持输出的某一方差一直取最小。</p>
<ol>
<li>由于输出中必须包含当前时刻的控制量𝑢(𝑘)才能通过使得输出的方差取最小求得当前时刻的控制量，而系统存在𝑑步的纯延时，因此包含当前时刻控制量的最早时刻的系统输出是𝑦(𝑘 + 𝑑) 。这意味着，我们可以选择𝑦(𝑘 + 𝑑) 、并通过使得包含𝑦(𝑘 + 𝑑) 的某一随机变量的方差取最小来计算𝑢(𝑘)。</li>
<li>数学上，用𝑘时刻和之前时刻的控制量和输出量将实际输出𝑦(𝑘 + 𝑑)表示出来的式子称为对𝑘 + 𝑑时刻的实际输出𝑦(𝑘 + 𝑑)的预测模型，因此我们也将实际输出𝑦(𝑘 + 𝑑)称为预测模型的输出。𝑘对每个时刻均成立。</li>
<li>由于未来时刻的实际输出𝑦(𝑘 + 𝑑)是未知的，因此我们只能将其看作一个变量。考虑到当前时刻到𝑘 + 𝑑时刻这段时间内，干扰一直影响着系统，我们进<br>一步将实际输出或预测模型的输出𝑦(𝑘 + 𝑑)看作一个随机变量是合理的。</li>
<li>由于自校正的功能一般都是用小型计算机或微处理器实现，因此受控系统的数学模型都用离散形式。<h3 id="1-3单输入单输出受控系统模型"><a href="#1-3单输入单输出受控系统模型" class="headerlink" title="1.3单输入单输出受控系统模型"></a>1.3单输入单输出受控系统模型</h3>&emsp;&emsp;可以用受控自回归滑动平均模型（CARMA）表示（线性、定常、离散）：<br><img src="https://s2.ax1x.com/2020/03/07/3jlrP1.jpg" alt="图"><br>&emsp;&emsp;其中，𝑦(𝑘)为𝑘时刻的输出；𝑢(𝑘)为𝑘时刻的控制输入；{𝜈(𝑘)}是零均值白噪声序列，𝑑为相应滞后步数。引入单位滞后算子𝑞−1，上式可写为<br><img src="https://s2.ax1x.com/2020/03/07/3j3JnU.jpg" alt="图"><br>&emsp;&emsp;其中，<br><img src="https://s2.ax1x.com/2020/03/07/3j3RNd.jpg" alt="图"><br>&emsp;&emsp;红色部分称为滑动平均项，绿色部分称为自回归项。（2）式也可写为：<br><img src="https://s2.ax1x.com/2020/03/07/3j89DU.jpg" alt="图"><br>&emsp;&emsp;其中，红色部分被称为过程或对象模型；绿色部分被称为噪声模型，也称为成形滤波器。<br><img src="https://i.loli.net/2020/03/07/ulotJHgsEwnN8ij.jpg" alt="5.JPG"><br>&emsp;&emsp;绿色部分能看作是白噪声经线性环节的输出，一般为有色噪声。<br>&emsp;&emsp;一般地，多项式𝑃 𝑧 在𝑧平面上的根或零点指满足𝑃 𝑧 = 0的𝑧的取值。若𝑃 𝑧 的根在𝑧平面上的单位圆内，即𝑧 &lt; 1，则称𝑃 𝑧 为Hurwitz多项式。<h2 id="2-参数已知最小方差控制"><a href="#2-参数已知最小方差控制" class="headerlink" title="2.参数已知最小方差控制"></a>2.参数已知最小方差控制</h2>&emsp;&emsp;假定系统（2）满足以下条件：</li>
</ol>
<blockquote>
<p>受控系统的时延𝑑及延迟算子多项式𝐴、𝐵和𝐶的阶次及系数都是已知的；<br>多项式𝐵和𝐶均为Hurwitz多项式。</p>
</blockquote>
<p>&emsp;&emsp;𝑦(𝑘 + 𝑑)是一个未知的随机变量，我们通过保证包含𝑦(𝑘 + 𝑑)的某一随机变量的方差取最小来设计当前时刻的控制量𝑢(𝑘)。考虑到只能使用当前时刻和过去时刻的输入和输出值，我们需要将𝑦(𝑘 + 𝑑)表达为当前和过去时刻的输入和输出的表达式，然后设计𝑢(𝑘)。由于系统模型（2）中不含实际输出𝑦(𝑘 + 𝑑)，因此需要对模型（2）进行变换以得到包含𝑦(𝑘 + 𝑑)的模型，这样即可用于实现包含𝑦(𝑘 + 𝑑)的某一随机变量的方差的最小化。将基于模型（2）变换得到的、包含𝑦(𝑘 + 𝑑)的模型称为预测模型。</p>
<h3 id="2-1最小方差预测得出现"><a href="#2-1最小方差预测得出现" class="headerlink" title="2.1最小方差预测得出现"></a>2.1最小方差预测得出现</h3><p><strong>几个符号的含义</strong></p>
<p>&emsp;&emsp;𝑦(𝑘+𝑑)：未来时刻𝑘+𝑑的系统实际输出本身，或𝑘+𝑑时刻预测模型的输出，代表一个随机变量。</p>
<p>&emsp;&emsp;𝑦𝑘+𝑑/𝑘：基于𝑘和以前时刻的输入输出数据{𝑢𝑖,𝑦𝑖,𝑖≤𝑘}，对未来时刻𝑘+𝑑时的系统实际输出本身或预测模型输出𝑦(𝑘+𝑑)的预测估计。也记为 𝑦𝑘+𝑑/𝑘。</p>
<p>&emsp;&emsp;𝑦𝑘+𝑑/𝑘=𝑦𝑘+𝑑−𝑦𝑘+𝑑/𝑘：预测误差。也记为 𝑦𝑘+𝑑。</p>
<p><strong>预测模型</strong></p>
<p>&emsp;&emsp;将（3）式写为<br><img src="https://i.loli.net/2020/03/07/eaCUg8oiNpv1JVQ.jpg" alt="6.JPG"><br>&emsp;&emsp;令红色部分为<br><img src="https://i.loli.net/2020/03/07/E3mj9yfYATwCRZz.jpg" alt="7.JPG"><br>&emsp;&emsp;其中<br><img src="https://i.loli.net/2020/03/07/GNU3MnRZq5jcW74.jpg" alt="8.JPG"><br>&emsp;&emsp;基于引入𝑞−𝑑的目的，由（6）式中的红色部分可知，𝐹 𝑞−1 的次数是𝑑 − 1，即𝑛𝑓 = 𝑑 − 1</p>
<p>&emsp;&emsp;将（5）式代入（4）式可得<br><img src="https://i.loli.net/2020/03/07/39nFPQXOfBtvRil.jpg" alt="9.JPG"><br>&emsp;&emsp;由（3）式可得<br><img src="https://i.loli.net/2020/03/07/Fk9UpmAMrB8Ooys.jpg" alt="10.JPG"><br>&emsp;&emsp;将（7）式代入（6）式可得<br><img src="https://i.loli.net/2020/03/07/TnhFeWvacp8zCro.jpg" alt="11.JPG"><br>&emsp;&emsp;观察（8）式，可以推测：红色部分是对于实际输出𝑦𝑘+𝑑的最优预测值。</p>
<p><strong>最优预测器</strong></p>
<p><img src="https://i.loli.net/2020/03/07/rtQeW4mSYxX3u9j.jpg" alt="12.JPG"><br>&emsp;&emsp;由于𝜈(𝑘 + 𝑑)与𝑦(𝑘)、𝑢(𝑘)相互独立，因此也与𝑦 𝑘 + 𝑑/𝑘 相互独立，故上式右边最后一项为0. 第一项是不可预测的，所以欲使𝐽1最小，只有使上式右边第二项为0，此时有：<br><img src="https://i.loli.net/2020/03/07/mop15JCzMRlgHbE.jpg" alt="13.JPG"><br>&emsp;&emsp;最小预测方差为：<br><img src="https://i.loli.net/2020/03/07/PfLx3grQEWSABhT.jpg" alt="14.JPG"><br>&emsp;&emsp;以上的预测模型以及最优预测器均是在假定𝐶 𝑞−1 是Hurwitz多项式的前提下得出的结果，即𝐶 𝑞−1 关于𝑞的根全部落在𝑞平面的单位圆内，这就保证了初始条件对最优预测器的作用与影响是以指数型速度衰减的。所以𝑘足够大时相当于稳态下的预测，也即初始条件的影响就无关紧要了。有时又称为最优稳态预测器。已有人提出当𝐶 𝑞−1 具有单位圆上零点的次最优预测器。</p>
<p>&emsp;&emsp;最优预测器（9）中出现了𝐹 𝑞−1 和𝐺 𝑞−1 ，故使用中必须确定出这两个量。一般地，当多项式𝐴 𝑞−1 、𝐶 𝑞−1 和时延步数𝑑已知后，这两个量可通过求解Diophantine方程唯一确定</p>
<p>&emsp;&emsp;Diophantine方程有两种解法，一种是长除法，另一种是比较系数法。</p>
<h3 id="2-2最小方差控制"><a href="#2-2最小方差控制" class="headerlink" title="2.2最小方差控制"></a>2.2最小方差控制</h3><p>&emsp;&emsp;通过使得实际输出𝑦(𝑘 + 𝑑)与期望输出𝑦𝑟 (𝑘 + 𝑑)之间的误差的方差𝐽 =𝐸 𝑦 𝑘 + 𝑑 − 𝑦𝑟 (𝑘 + 𝑑) 2 取最小，设计当前时刻的控制律𝑢(𝑘)。<br>&emsp;&emsp;将预测模型（8）代入性能指标𝐽，并考虑最优预测方程（9）有：<br><img src="https://i.loli.net/2020/03/07/mN6cyEAbShgKVxv.jpg" alt="15.JPG"><br>&emsp;&emsp;上式右边第一项不可控，所以欲使𝐽最小，必须使<br><img src="https://i.loli.net/2020/03/07/OvQV5YT6qmSe9Mi.jpg" alt="16.JPG"><br>&emsp;&emsp;将最优预测的具体表达式代入上式，并经整理可得<br><img src="https://i.loli.net/2020/03/07/en4SYD6gtfmbFLq.jpg" alt="17.JPG"><br>&emsp;&emsp;从以上推导过程可以看出，最小方差控制律实际上是令𝑘 + 𝑑时刻的最优输出预测值等于期望输出时所得到的控制量。</p>
<p>&emsp;&emsp;特别地，对于输出调节问题，有𝑦𝑟 𝑘 + 𝑑 = 0。此时的最小方差控制律也称为最小方差调节律，可以简化为<br><img src="https://i.loli.net/2020/03/07/eGkDbzXmyTLUOcv.jpg" alt="18.JPG"><br><strong>最小方差控制设计概括</strong></p>
<ol>
<li>设被控过程的差分方程为𝐴 𝑞−1 𝑦 𝑘 = 𝐵 𝑞−1 𝑞−𝑑 𝑢 𝑘 + 𝐶 𝑞−1 𝜈 𝑘 ，其中，{𝜈(𝑘)}是独立同分布的白噪声序列，即𝜈(𝑘)~𝑁(0, 𝜎2)；𝐵和𝐶均为Hurwitz多项式。那么，最小方差调节律为<br><img src="https://i.loli.net/2020/03/07/SCfPH9GZ26sJLkx.jpg" alt="19.JPG"></li>
<li>其中，多项式𝐹 𝑞−1 和𝐺 𝑞−1 的阶分别为𝑑 − 1和𝑛𝑎 − 1；多项式的系数可通过求解下列Diophantine方程来确定：<br><img src="https://i.loli.net/2020/03/07/Roa9pSxhB1PVNrU.jpg" alt="20.JPG"></li>
<li>控制律作用下的输出误差是𝑣(𝑘 + 𝑑)的𝑑 − 1阶滑动平均：<br><img src="https://pic.downk.cc/item/5e63a9e998271cb2b8f41296.jpg" alt="20.JPG"></li>
<li>输出误差的最小方差为<br><img src="https://pic.downk.cc/item/5e63a9e998271cb2b8f4129d.jpg" alt="20.JPG"></li>
</ol>
<p><strong>最小方差控制的特性</strong></p>
<ol>
<li>输出误差的方差随系统延迟𝑑的增加而增加，即特性变坏。</li>
<li>当增益𝑏0的绝对值很小时，调节器的增益很大，将导致过大的控制信号𝑢(𝑘)，这会加速调节器执行机构的磨损和损坏。</li>
<li>当受控对象是非最小相位时，最小方差自校正调节系统是不稳定的。</li>
<li>最小方差自校正调节器具有自校正特性。</li>
</ol>
<h2 id="3-参数未知情况下最下方差自校正控制"><a href="#3-参数未知情况下最下方差自校正控制" class="headerlink" title="3.参数未知情况下最下方差自校正控制"></a>3.参数未知情况下最下方差自校正控制</h2><p>&emsp;&emsp;最小方差控制适用于对象参数已知和恒定的场合。当对象受内外干扰的影响以致于其模型不能再有效描述该对象时，就需要对过程模型进行修改，以适应环境条件的变化。修改模型时，可以利用输入输出数据重新辨识模型的结构和参数，也可以只辨识模型的参数而认为结构不变。这就是说，当对象参数变化时，能随着参数的变化在线估计出系统模型，并基于此模型设计出来的、使得期望性能指标达到最优（如输出误差的方差最小）的控制器称为自校正调节器。</p>
<p>&emsp;&emsp;当被控对象的参数未知或变化时将递推最小二乘参数估计与最小方差控制结合起来，就形成了最小方差自校正器。</p>
<p>&emsp;&emsp;自校正控制的两种形式：间接自校正控制和直接自校正控制。</p>
<h3 id="3-1最小方差自校正调节器"><a href="#3-1最小方差自校正调节器" class="headerlink" title="3.1最小方差自校正调节器"></a>3.1最小方差自校正调节器</h3><p>&emsp;&emsp;此时，有𝑦𝑟 𝑘 + 𝑑 = 0。参照最小方差调节器(15)的形式，我们只需要估计出𝐺 𝑞−1 中包含的𝑛𝑎个参数和𝐵 𝑞−1 𝐹 𝑞−1 中包含的𝑛𝑏 + 𝑑个参数即可用于调节器的设计。将预测模型(8)重写如下：<br><img src="https://pic.downk.cc/item/5e63af4498271cb2b8f6669e.jpg" alt><br>&emsp;&emsp;最小方差控制由(15)式确定，即：<br><img src="https://pic.downk.cc/item/5e63af0898271cb2b8f650ce.jpg" alt></p>
<h3 id="3-2最小方差自校正控制器"><a href="#3-2最小方差自校正控制器" class="headerlink" title="3.2最小方差自校正控制器"></a>3.2最小方差自校正控制器</h3><h3 id="3-3最小方差自校正控制算法的收敛性"><a href="#3-3最小方差自校正控制算法的收敛性" class="headerlink" title="3.3最小方差自校正控制算法的收敛性"></a>3.3最小方差自校正控制算法的收敛性</h3><p>&emsp;&emsp;对于最小方差自校正调节算法的收敛性，Åström等人于1973年给出过结论：</p>
<ol>
<li>设被控对象的参数辨识方程如(21)式所示，闭环系统的调节律如(23)所示，若𝑘⟶∞时，参数估计收敛到真值，即 𝜃⟶𝜃’，并且𝐺𝑞−1和𝐹′𝑞−1无公因子，则调节器(23)最终收敛到系统参数已知时的最小方差调节律。</li>
<li>对于最小方差自校正控制器算法也有类似的结论，这时控制器(28)收敛到参数已知时的最小方差控制规律。</li>
</ol>
<p>&emsp;&emsp;总之，被估计的参数收敛到真值，是调节或控制规律收敛到最小方差规律的前提。</p>
]]></content>
      <categories>
        <category>控制理论</category>
      </categories>
      <tags>
        <tag>最小方差</tag>
        <tag>自校正</tag>
      </tags>
  </entry>
  <entry>
    <title>反向传播网络</title>
    <url>/2020/03/05/006%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="反向传播网络"><a href="#反向传播网络" class="headerlink" title="反向传播网络"></a>反向传播网络</h1><p>&emsp;&emsp;反向传播网络（Back-Propagation Network,简称BP网络）是对非线性可微分函数进行权值训练的多层前向网络。在人工神经网络的实现应用过程中，80%-90%的采用BP网络或它的变化形式</p>
<a id="more"></a>
<h2 id="1-反向传播网络的模型与结构"><a href="#1-反向传播网络的模型与结构" class="headerlink" title="1.反向传播网络的模型与结构"></a>1.反向传播网络的模型与结构</h2><p>&emsp;&emsp;BP网络是前向网络的核心内容，体现了神经网络的最精华的一部分。一个具有r个输入和一个隐含层的神经网络模型结构如图所示<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.JPG" alt="图"></p>
<center>网络模型结构</center>

<p>&emsp;&emsp;在人们掌握反向传播网络设计之前，感知器和自适应线性元件都只能适应于单层的网络模型训练，二者的差别主要在激活函数上，前者是二值型的，后者是线性的。反向传播网络具有一个或多个隐含层，除了在多层网络结构上与之前介绍的模型有不同外，其主要差别在激活函数上。反向传播网络要求激活函数是处处可微的，所以其就不可以采用二值型阈值函数{0，1}或有符号函数{-1，1}，反向传播网络经常使用的是S型激活函数，此激活函数常用对数或双曲正切等一类S形状的曲线表示，如对数S型激活函数关系为：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F1.JPG" alt="图"><br>&emsp;&emsp;双曲正切S型激活函数输入输出函数关系为：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F2.JPG" alt="图"><br>&emsp;&emsp;下图是是对数S型激活函数和带有偏差的双曲正切S型激活函数的图形<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%AF%B9%E6%95%B0%E5%9E%8B.JPG" alt="图"></p>
<center>对数型</center>

<p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%81%8F%E5%B7%AE%E5%9E%8B.JPG" alt="图"></p>
<center>双曲正切型</center>

<h2 id="2-BP算法（误差反向传播法：Back-Propergation）"><a href="#2-BP算法（误差反向传播法：Back-Propergation）" class="headerlink" title="2.BP算法（误差反向传播法：Back-Propergation）"></a>2.BP算法（误差反向传播法：Back-Propergation）</h2><p><img src="http://q6q6hf6hf.bkt.clouddn.com/BP%E8%92%9C%E8%B4%A9.JPG" alt="图"></p>
<center>具有一个隐含层的简化网络图</center>

<p>&emsp;&emsp;设输入为P，输入神经元有r个，隐含层内有s1个神经元，激活函数为F1，输出层内有s2个神经元，对应的激活函数为F2，输出为A，目标矢量为T 。</p>
<h3 id="2-1信息的正向传递"><a href="#2-1信息的正向传递" class="headerlink" title="2.1信息的正向传递"></a>2.1信息的正向传递</h3><h4 id="1-隐含层中第i个神经元的输出为："><a href="#1-隐含层中第i个神经元的输出为：" class="headerlink" title="(1) 隐含层中第i个神经元的输出为："></a>(1) 隐含层中第i个神经元的输出为：</h4><p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F3.JPG" alt="图"></p>
<h4 id="2-输出层第k个神经元的输出为："><a href="#2-输出层第k个神经元的输出为：" class="headerlink" title="(2) 输出层第k个神经元的输出为："></a>(2) 输出层第k个神经元的输出为：</h4><p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F4.JPG" alt="图"></p>
<h4 id="3-定义误差函数为："><a href="#3-定义误差函数为：" class="headerlink" title="(3) 定义误差函数为："></a>(3) 定义误差函数为：</h4><p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F5.JPG" alt="图"></p>
<h3 id="2-2利用梯度下降法求权值变化及误差的反向传播"><a href="#2-2利用梯度下降法求权值变化及误差的反向传播" class="headerlink" title="2.2利用梯度下降法求权值变化及误差的反向传播"></a>2.2利用梯度下降法求权值变化及误差的反向传播</h3><h4 id="1-输出层的权值变化"><a href="#1-输出层的权值变化" class="headerlink" title="(1) 输出层的权值变化"></a>(1) 输出层的权值变化</h4><p>&emsp;&emsp;对从第i个输入到第k个输出的权值有：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F6.JPG" alt="图"><br>&emsp;&emsp;其中：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F7.JPG" alt="图"><br>&emsp;&emsp;同理可得：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F8.JPG" alt="图"></p>
<h4 id="2-隐含层权值变化"><a href="#2-隐含层权值变化" class="headerlink" title="(2) 隐含层权值变化"></a>(2) 隐含层权值变化</h4><p>&emsp;&emsp;对从第j个输入到第i个输出的权值，有：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F9.JPG" alt="图"><br>&emsp;&emsp;其中：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F10.JPG" alt="图"><br>&emsp;&emsp;同理可得：<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%85%AC%E5%BC%8F11.JPG" alt="图"></p>
<h3 id="2-3误差反向传播的流程"><a href="#2-3误差反向传播的流程" class="headerlink" title="2.3误差反向传播的流程"></a>2.3误差反向传播的流程</h3><p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E5%9B%BE%E8%A7%A3.JPG" alt="图"></p>
<center>反向传播网络工作流程</center>

<h2 id="3-BP网络的设计"><a href="#3-BP网络的设计" class="headerlink" title="3.BP网络的设计"></a>3.BP网络的设计</h2><p>&emsp;&emsp;在进行BP网络的设计时，一般应从网络的层数、每层网络中的神经元个数和激活函数、初始值以及学习速率等几个方面考虑。下面讨论一下各自速率选区的原则。</p>
<h3 id="3-1网络的层数"><a href="#3-1网络的层数" class="headerlink" title="3.1网络的层数"></a>3.1网络的层数</h3><p>&emsp;&emsp;理论上已经证明：具有偏差和至少一个S型隐含层加上一个线性输出层的网络，能够逼近任何有理函数。增加层数可以进一步降低误差提高精度，但同时也使网络复杂化，从而增加了网络权值的训练时间。而误差精度的提高也可以通过增加隐含层神经元的数目来获得，其训练效果也比增加层数更容易观察和调整。<br>考虑两个单元输入的联想问题。其输入和输出矢量分别为：</p>
<p>&emsp;&emsp;P= [ 3 2 ], T = [ 0.4 0.8]</p>
<p>&emsp;&emsp;当采用含有一个对数S 型单层网络求解时，可求得解为：</p>
<p>&emsp;&emsp;w= 0.3350</p>
<p>&emsp;&emsp;b= 0.5497</p>
<p>&emsp;&emsp;此时所达到的误差平方和err_goal &lt; 0.001 。若将这个误差转换成输出误差时，其绝对误差约为 0.02</p>
<p>&emsp;&emsp;若采用自适应线性网络来实现此联想，得解为：</p>
<p>&emsp;&emsp;w= 0.08</p>
<p>&emsp;&emsp;b= 0.64</p>
<p>&emsp;&emsp;此网络误差为：e = T Y = 0 。<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%BD%91%E7%BB%9C.JPG" alt="图"></p>
<center>两种结构比较</center>

<h3 id="3-2隐含层的神经元数"><a href="#3-2隐含层的神经元数" class="headerlink" title="3.2隐含层的神经元数"></a>3.2隐含层的神经元数</h3><p>&emsp;&emsp;网络训练精度的提高可以通过采用增加隐含层神经元的数目来提高，其在结构实现上要比增加神经元层数要简单的多。具体的数是多少要综合考虑精度和复杂度的要求。<br>&emsp;&emsp;用两层BP网络实现“异或”功能。</p>
<p><img src="http://q6q6hf6hf.bkt.clouddn.com/%E4%B8%8D%E5%90%8C%E5%B1%82%E6%95%B0.JPG" alt="图"></p>
<center>每层不同神经元数结构</center>

<h3 id="3-3初始权值的选取"><a href="#3-3初始权值的选取" class="headerlink" title="3.3初始权值的选取"></a>3.3初始权值的选取</h3><p>&emsp;&emsp;较好的初始值时的训练效果的观察。以前面的实例为例，当改用下列初始值：net = initnw(net,1);在这个初始值函数下，获得的一组初始值为：</p>
<p>&emsp;&emsp;W1 = [7 ; 7 ;7 ; 7 ; 7];B1 = [7.0000; 3.5000; 0; 3.5000; 7.0000];</p>
<p>&emsp;&emsp;W2 = [0.2698 0.2135 0.1831 0.7605 0.9237];B2 = [0.0828];</p>
<p>&emsp;&emsp;重新训练网络后，相对于原先随机初始值时的6801 次的训练，仅用了 410 次，就达到了同样的目标误差。这比标准的反向传播法的训练次数少了 15 倍。</p>
<h3 id="3-4学习速率的影响"><a href="#3-4学习速率的影响" class="headerlink" title="3.4学习速率的影响"></a>3.4学习速率的影响</h3><p>&emsp;&emsp;观察不同学习速率的影响<br><img src="http://q6q6hf6hf.bkt.clouddn.com/%E5%AD%A6%E4%B9%A0%E9%80%9F%E7%8E%87.JPG" alt="图"></p>
<center>研究不同学习速率影响</center>

<h2 id="4-BP网络的应用"><a href="#4-BP网络的应用" class="headerlink" title="4.BP网络的应用"></a>4.BP网络的应用</h2><p>&emsp;&emsp;1.<strong>函数逼近</strong>：用输入矢量和相应的输出矢量训练一个网络逼近一个函数；<br>&emsp;&emsp;2.<strong>模式识别</strong>：用一个特定的输出矢量将它与输入矢量联系起来；<br>&emsp;&emsp;3.<strong>分类</strong>：把输入矢量以所定义的合适方式进行分类；<br>&emsp;&emsp;4.<strong>数据压缩</strong>：减少输出矢量维数以便于传输或存储。</p>
<h2 id="5-BP网络的限制与不足"><a href="#5-BP网络的限制与不足" class="headerlink" title="5.BP网络的限制与不足"></a>5.BP网络的限制与不足</h2><p>&emsp;&emsp;<strong>1.需要较长的训练时间</strong></p>
<p>&emsp;&emsp;<strong>2.某些情况下完全不能训练</strong></p>
<p>&emsp;&emsp;<strong>3.可能陷入局部极小值</strong></p>
]]></content>
      <categories>
        <category>控制理论</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>反向传播</tag>
      </tags>
  </entry>
  <entry>
    <title>自适应控制（一）</title>
    <url>/2020/03/02/005%E8%87%AA%E9%80%82%E5%BA%94%E6%8E%A7%E5%88%B6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="自适应控制"><a href="#自适应控制" class="headerlink" title="自适应控制"></a>自适应控制</h1><p>&emsp;&emsp;实际控制系统中，绝大多数被控对象具有不确定性，即其动力学模型和所处的环境不是完全已知的，表现为事先难以确定被控对象的模型参数，或者模型参数是时变的，或者被控对象本身的特性发生变化，此时就需要引入自适应控制。</p>
<a id="more"></a>
<h2 id="1自适应控制的引入"><a href="#1自适应控制的引入" class="headerlink" title="1自适应控制的引入"></a>1自适应控制的引入</h2><h3 id="1-1传统控制理论的局限性"><a href="#1-1传统控制理论的局限性" class="headerlink" title="1.1传统控制理论的局限性"></a>1.1传统控制理论的局限性</h3><p>&emsp;&emsp;现代控制理论通常研究的对象是多输入多输出的线性系统以及一般的非线性系统，当其状态空间运动方程已知，即可借助最优控制理论设计最优控制器，使得控制系统的某一性能指标达到最优（运行时间最短、能耗最小等）。在研究前需要获得系统动力学的数学模型（参数结构），也就是说系统的模型是已知的。但在实际中，绝大多数被控对象具有不确定性，即其动力学模型和所处的环境不是完全已知的，表现为事先难以确定被控对象的模型参数，或者模型参数是时变的，或者被控对象本身的特性发生变化。</p>
<h3 id="1-2自适应控制的发展历史"><a href="#1-2自适应控制的发展历史" class="headerlink" title="1.2自适应控制的发展历史"></a>1.2自适应控制的发展历史</h3><p>&emsp;&emsp;1958年，美国麻省理工学院(MIT)的Whitaker教授首先提出了飞机自动驾驶仪的模型参考自适应控制方案，称为MIT方案。在该方案中采用局部参数优化理论设计自适应控制律，但保证不了系统的稳定性。</p>
<p>&emsp;&emsp;为解决稳定性问题，1965年前后，Shackcloth和Butchar、Parks等人独立引进Lyapunov方法进行模型参考自适应控制律的设计，可保证系统的稳定性。</p>
<p>&emsp;&emsp;1974年，美国的Monopoli提出了一种广义误差信号法，只要采用对象的输入和输出就可以完成设计，避免了微分运算。Monopoli的工作具有里程碑性的意义，他使得模型参考自适应方法变得实用，去掉了求微分运算、增加了稳定性，更适合工程应用。</p>
<p>&emsp;&emsp;1973年，瑞典学者K.J.Åström和B.Wittenmark首先提出最小方差自校正调节器，很容易实现，可以在生产中应用。</p>
<h3 id="1-3自适应控制的特点"><a href="#1-3自适应控制的特点" class="headerlink" title="1.3自适应控制的特点"></a>1.3自适应控制的特点</h3><ul>
<li>能够检测到对象的（性能或模型参数）变化</li>
<li>能够产生基于这种变化的自适应控制率</li>
<li>具有实现可变控制律的可调控制器<h3 id="1-4自适应控制系统基本结构"><a href="#1-4自适应控制系统基本结构" class="headerlink" title="1.4自适应控制系统基本结构"></a>1.4自适应控制系统基本结构</h3>&emsp;&emsp;在经典控制系统的基础之上加入对象的变化检测环节与自适应机构（下图1），对象的变化检测环节是根据系统或对象的输入、输出、可能检测到的干扰来确定出对象本身的变化，例如性能指标值的变化、对象数学模型中某些参数值的变化等，此外也有信息积累的功能。自适应机构根据检测到的对象变化按预先制定的规则产生自适应调节方案，以调整控制器并逐渐实现期望的控制目标。其中，自适应调节方案分参数调节和结构调节两大类，前者只改变控制器的参数，如PID参数整定；后者则会改变控制律的形式。</li>
</ul>
<p><img src="http://q6o2z8cws.bkt.clouddn.com/%E8%87%AA%E9%80%82%E5%BA%94%E7%BB%93%E6%9E%84.JPG" alt="图"></p>
<h3 id="1-5-自适应控制系统中控制器设计的方法"><a href="#1-5-自适应控制系统中控制器设计的方法" class="headerlink" title="1.5 自适应控制系统中控制器设计的方法"></a>1.5 自适应控制系统中控制器设计的方法</h3><blockquote>
<ul>
<li>基于优化策略的自校正控制器</li>
</ul>
</blockquote>
<p>&lt;divalign=center&gt;<img src="http://q6o2z8cws.bkt.clouddn.com/04.JPG" divalign="center"></p>
<p>基于优化策略的自校正控制器主要有如下三种方法：</p>
<p>&emsp;&emsp;1. 最小方差控制</p>
<img src="http://q6o2z8cws.bkt.clouddn.com/01.JPG">

<p>&emsp;&emsp;2. 广义最小方差控制</p>
<img src="http://q6o2z8cws.bkt.clouddn.com/02.JPG">

<p>&emsp;&emsp;3. LQG(先行二次高斯)控制</p>
<img src="http://q6o2z8cws.bkt.clouddn.com/03.JPG">

<blockquote>
<ul>
<li>基于常规控制策略的自校正器</li>
</ul>
</blockquote>
<p>&emsp;&emsp;1. 极点配置法：</p>
<p>&emsp;&emsp;把期望的闭环系统的行为用期望传递函数的（零）极点的位置表示，设计自校正控制器的目的是，保证控制器作用下闭环系统的（零）极点等于或收敛于期望的（零）极点。</p>
<p>&emsp;&emsp;2. PID控制器</p>
<p>&emsp;&emsp;讨论在常规PID控制器作用下如何消除干扰的特殊问题。</p>
<blockquote>
<ul>
<li>模型参考自适应控制</li>
</ul>
</blockquote>
<p>&emsp;&emsp;通过使参考模型输出与对象输出的偏差按一个确定的动态过程趋于零来设计控制律。</p>
<h3 id="1-6自适应控制控制系统主要研究问题"><a href="#1-6自适应控制控制系统主要研究问题" class="headerlink" title="1.6自适应控制控制系统主要研究问题"></a>1.6自适应控制控制系统主要研究问题</h3><p>&emsp;&emsp;自适应控制针对对象和其所处的环境的变化而言，因此需要分析对象的不确定性，其理论涉及概率论、随机过程和系统控制理论。其根本在于设计一个能适应对象和环境变化的自适应控制律。根据对控制系统的基本要求，与自适应律相关的问题有稳定性、收敛性和鲁棒性。</p>
<blockquote>
<ul>
<li>稳定性</li>
</ul>
</blockquote>
<p>&emsp;&emsp;在模型参考自适应控制中，目的是使𝑒⟶0，即要求误差满足Lyapunov渐近稳定性，故稳定性理论是模型参考自适应控制的理论基础。在设计模型参考自适应控制中，Lyapunov稳定性理论和Popov超稳定性理论还是重要的设计工具。</p>
<blockquote>
<ul>
<li>收敛性</li>
</ul>
</blockquote>
<p>&emsp;&emsp;在自适应控制中，收敛性多指算法的收敛性。自适应机构修正控制器从而形成的控制算法、或自校正的参数辨识算法，一般都会出现递推形式，即根据前一步的结果来计算这一步的控制律和参数值。有效的控制结果要求算法必须在有限步后满足要求。收敛算法意味着，参数值最终会收敛到一个确定值。数学上，收敛指一个无限过程。实际使用时，可以指定一个递进误差界，当两步计算所得的参数值之差小于这个误差界时就认为算法已收敛到极限值，停止计算。</p>
<blockquote>
<ul>
<li>鲁棒性</li>
</ul>
</blockquote>
<p>&emsp;&emsp;鲁棒控制和自适应控制的兼容形成鲁棒自适应控制，即自适应控制律具有鲁棒性。鲁棒自适应控制的动机：对于对象或环境的细小变化就引起自适应控制的动作，很多时候是没有必要的，而且过于频繁的启停会大大缩短设备的寿命，甚至导致系统不稳定。</p>
]]></content>
      <categories>
        <category>控制理论</category>
      </categories>
      <tags>
        <tag>自适应</tag>
      </tags>
  </entry>
  <entry>
    <title>博客域名更改</title>
    <url>/2020/02/29/004%E6%9B%B4%E6%94%B9%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>&emsp;&emsp;利用hexo和Github搭建完博客后默认的域名是以.github.io结尾的，依托于github的服务器，除非利用国外的IP去访问否则在国内博客加载的速度非常慢因此下面介绍如何购买阿里云的域名来重新部署自己的博客</p>
<h1 id="域名更改步骤总结"><a href="#域名更改步骤总结" class="headerlink" title="域名更改步骤总结"></a>域名更改步骤总结</h1><a id="more"></a>
<h2 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1 购买域名"></a>1 购买域名</h2><p>&emsp;&emsp;首先注册一个阿里云账号（建议支付宝快捷方式注册）注册完后登录进入阿里云。在域名搜索栏中输入自己想要购买的域名，阿里云会根据域名的流行度推荐不同后缀的域名当然他们的价位也大不相同，根据自己的需要选择购买域名的时间然后加入购物车</p>
<p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1582992536696&di=e93f6201a2f40cd28e19553968fea5cf&imgtype=0&src=http%3A%2F%2Fimg.cndesign.com%2Fupload%2Fnews%2F20190322%2F6368885998231690521778966.png" alt="aliyun"></p>
<p>&emsp;&emsp;在进行支付之前需要完善自己的信息包括邮箱身份证以及上传身份证正面图片，然后提交审核，审核时间大概在五分钟左右（赚钱的行当当然效率高）。接着完成支付，然后就恭喜你你可以有自己的域名了。</p>
<h2 id="2-解析域名并在Github中添加域名信息"><a href="#2-解析域名并在Github中添加域名信息" class="headerlink" title="2 解析域名并在Github中添加域名信息"></a>2 解析域名并在Github中添加域名信息</h2><p>&emsp;&emsp;在新购买的域名右侧点击解析，然后去填写里面的内容：主机记录–@ ；记录类型选择–CNAME；解析线路默认；记录值–username.github.io;(最关键)</p>
<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=655537167,4042667359&fm=26&gp=0.jpg" alt="avatar"></p>
<p>&emsp;&emsp;然后回到Github中博客的仓库，进入最右侧的Settings，下拉进入到GithubPages，在custom domain中填入自己购买的域名然后点击save</p>
<p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2710692682,3036501525&fm=15&gp=0.jpg" alt="avatar"></p>
<p>&emsp;&emsp;这时再次输入username.github.io网址栏中会自动变为购买的域名，但刚开始可能加载不出来任何东西，建议等待一段时间后再次尝试</p>
<h2 id="3-完结"><a href="#3-完结" class="headerlink" title="3 完结"></a>3 完结</h2><p>&emsp;&emsp;等待一段时间后再次尝试，发现已经正常加载，而且速度快了很多，但是现阶段存在一个问题，自己刚刚生效的域名在QQ中分享时会出现骚扰网站警告⚠，Chrome浏览器中也有拦截，目前还在申诉中，但继续使用usemane.github.io去访问博客不会有警告，网址栏会自动转换为自己购买的域名，加载速度也比较快。</p>
<p><img src="/2020/02/29/004%E6%9B%B4%E6%94%B9%E5%9F%9F%E5%90%8D/02.jpg" alt="02"></p>
]]></content>
      <tags>
        <tag>域名</tag>
        <tag>云服务</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Hexo搭建自己的博客</title>
    <url>/2020/02/28/003%E7%AC%AC%E4%B8%80%E7%AF%87%E6%AD%A3%E5%BC%8F%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Hexo博客搭建"><a href="#Hexo博客搭建" class="headerlink" title="Hexo博客搭建"></a>Hexo博客搭建</h1><a id="more"></a>
<p>今天在刷b站的时候无意中看到一位up主在自己的简介介绍了自己的个人博客，瞬时间我就萌生了搭建个人博客的年头，加之天气阴冷无事可做，当前手头上没有特别紧急的事情，于是一顿操作就搭起来了。</p>
<h2 id="1-搭建博客的方法"><a href="#1-搭建博客的方法" class="headerlink" title="1. 搭建博客的方法"></a>1. 搭建博客的方法</h2><p>主要是在跟着B站的一位UP主学着做的，详情可见链接<a href="https://www.bilibili.com/video/av44544186?t=1156" target="_blank" rel="noopener">搭建博客</a>基本上可以说按照着他的步骤一步一步来就可以成功。下面简要回顾一下搭建的基本步骤：</p>
<h3 id="1-1安装git"><a href="#1-1安装git" class="headerlink" title="1.1安装git"></a>1.1安装git</h3><p>之前只知道有github这个网站，实际上还有一个git软件，git可以用来托管自己的文件或代码方面分布式的交流,搭建hexo博客中对自己的博客设计都是通过git来提交的。<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1582913056223&di=1dc371b81afdf0748a5064ffa13fe66c&imgtype=0&src=http%3A%2F%2Fblog.lihaocheng.cn%2Fwp-content%2Fuploads%2F2019%2F03%2F19c3ae1c30f4c948e3de8c2c4226cebc.jpg" alt="git"></p>
<h3 id="1-2配置git"><a href="#1-2配置git" class="headerlink" title="1.2配置git"></a>1.2配置git</h3><h3 id="1-3安装Node-js软件"><a href="#1-3安装Node-js软件" class="headerlink" title="1.3安装Node.js软件"></a>1.3安装Node.js软件</h3><h3 id="1-4将网站部署到Github"><a href="#1-4将网站部署到Github" class="headerlink" title="1.4将网站部署到Github"></a>1.4将网站部署到Github</h3><p>这个步骤要注意自己的博客的网址名称必须要和自己的github账户username保持一致，即username.guithub.io</p>
<h3 id="1-5更换Blog主题"><a href="#1-5更换Blog主题" class="headerlink" title="1.5更换Blog主题"></a>1.5更换Blog主题</h3><p>默认的Blog不够简洁美观，可以按照推荐的yilia主题进行更换</p>
<h3 id="1-6丰富博客的功能和外观"><a href="#1-6丰富博客的功能和外观" class="headerlink" title="1.6丰富博客的功能和外观"></a>1.6丰富博客的功能和外观</h3><p>虽然yilia主题相较于默认的主题有很大改进，但其内部的细节仍有一些需要改进与细化的地方<br>。可以搜索一些大佬们总结的经验和模仿他们的设计风格。其实修改的过程也比较简单，进本是一些代码和参数的<br>ctrl C和ctrl V。</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h2><p>在功能预览网站local那个域名下博客加载速度很快，但真实域名的博客加载速度比较慢，毕竟人家是免费的，尤其是改动较大后首次进入。</p>
<h2 id="2-Markdown格式书写练习"><a href="#2-Markdown格式书写练习" class="headerlink" title="2. Markdown格式书写练习"></a>2. Markdown格式书写练习</h2><p>其实写博客的方式和CSDN基本上是相同的格式，渐渐的熟悉这种格式写起博客来<br>十分方便，戍边也能提升一下盲打的速度</p>
<h2 id="3-搭建完博客后今后的打算"><a href="#3-搭建完博客后今后的打算" class="headerlink" title="3. 搭建完博客后今后的打算"></a>3. 搭建完博客后今后的打算</h2><p>其实很多平台（CSDN，知乎，微博等）也提供了类似博客平台而且功能特别丰富，但是自己动手搭建的感觉是不同的。一个是知道博客的各个功能模块具体是怎样实现的，另外一个是可以直接利用自己的址去分享自己的博客（虽然大平台也可以分享自己的主页地址，但是感觉还是不一样，而且后期可以买个域名）</p>
<p>以后有了这个博客，平时可以写一些技术分享然后传上去，也可写一下个人的感悟和思考，自我的探索以及写一些小文章等等。加入生活没有诗意，那可还行！<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1582913205025&di=d28b5f55d7bf3ee903d23edf6c60afeb&imgtype=0&src=http%3A%2F%2F03.imgmini.eastday.com%2Fmobile%2F20180207%2F20180207070834_6d868feb7894e5a33a8f487af4f31e60_1.jpeg" alt="musk"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
